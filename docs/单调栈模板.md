# 单调栈模板总结 📚

> **单调栈（Monotonic Stack）** 是一种特殊的栈结构，栈内元素保持单调递增或单调递减的顺序。  
> 它是解决"下一个更大/更小元素"类问题的高效算法，时间复杂度为 O(n)。

---

## 📚 核心概念

**单调栈** 通过维护栈内元素的单调性，在遍历数组时可以快速找到每个元素的"下一个更大/更小"元素。

**核心思想**：
- 当遇到一个新元素时，不断弹出栈顶元素，直到满足单调性条件
- 被弹出的元素找到了它的"下一个更大/更小"元素
- 栈中存储的是**数组索引**而非元素值，方便计算距离

---

## 🎯 适用场景

单调栈适合解决以下**四类经典问题**：

| 问题类型 | 说明 | 栈类型 | 遍历方向 |
|---------|------|--------|---------|
| **下一个更大元素** | 找到每个元素右边第一个比它大的元素 | 单调递减栈 | 从左到右 |
| **下一个更小元素** | 找到每个元素右边第一个比它小的元素 | 单调递增栈 | 从左到右 |
| **上一个更大元素** | 找到每个元素左边第一个比它大的元素 | 单调递减栈 | 从右到左 |
| **上一个更小元素** | 找到每个元素左边第一个比它小的元素 | 单调递增栈 | 从右到左 |

**拓展应用**：
- 柱状图中最大的矩形（LeetCode 84）
- 接雨水（LeetCode 42）
- 去除重复字母（LeetCode 316）

---

## 🔧 通用模板代码

### 1. 单调递减栈 - 找"下一个更大元素"

```java
public int[] nextGreaterElement(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];
    Arrays.fill(result, -1); // 默认值设为-1（表示没找到）
    
    Stack<Integer> stack = new Stack<>(); // 单调递减栈，存储索引
    
    for (int i = 0; i < n; i++) {
        // 当前元素大于栈顶索引对应的元素时
        // 说明找到了栈顶元素的"下一个更大元素"
        while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
            int prevIndex = stack.pop();
            result[prevIndex] = nums[i]; // 或者 i - prevIndex（距离）
        }
        stack.push(i); // 将当前索引入栈
    }
    
    return result;
}
```

**栈的状态**：栈底到栈顶元素对应的值**递减**（大 → 小）

### 2. 单调递增栈 - 找"下一个更小元素"

```java
public int[] nextSmallerElement(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];
    Arrays.fill(result, -1);
    
    Stack<Integer> stack = new Stack<>(); // 单调递增栈，存储索引
    
    for (int i = 0; i < n; i++) {
        // 当前元素小于栈顶索引对应的元素时
        // 说明找到了栈顶元素的"下一个更小元素"
        while (!stack.isEmpty() && nums[i] < nums[stack.peek()]) {
            int prevIndex = stack.pop();
            result[prevIndex] = nums[i];
        }
        stack.push(i);
    }
    
    return result;
}
```

**栈的状态**：栈底到栈顶元素对应的值**递增**（小 → 大）

## 📝 经典例题：739. 每日温度

### 题目描述

给定每天的温度 `temperatures`，返回一个数组 `answer`，其中 `answer[i]` 表示第 `i` 天之后要等多少天才会有更高的温度。如果之后没有更高温度，则对应位置为 `0`。

**示例**：
```
输入：temperatures = [73,74,75,71,69,72,76,73]
输出：[1,1,4,2,1,1,0,0]
```

### 完整解法

```java
public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] res = new int[n];
    Stack<Integer> stack = new Stack<>(); // 单调递减栈，存储下标
    
    for (int i = 0; i < n; i++) {
        // 当前温度大于栈顶索引对应的温度时
        // 说明找到了栈顶元素的"下一个更高温度"
        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            int prevIndex = stack.pop(); // 弹出栈顶索引
            res[prevIndex] = i - prevIndex; // 计算天数差
        }
        stack.push(i); // 将当前索引入栈
    }
    
    // 栈中剩余的索引表示没有找到更高温度的日期，res 默认值已经是 0
    return res;
}
```

### 执行过程图解

以 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]` 为例：

```
i=0, temp=73: stack=[0]
i=1, temp=74: 74>73, pop 0, res[0]=1-0=1, stack=[1]
i=2, temp=75: 75>74, pop 1, res[1]=2-1=1, stack=[2]
i=3, temp=71: 71<75, stack=[2,3]
i=4, temp=69: 69<71, stack=[2,3,4]
i=5, temp=72: 72>69, pop 4, res[4]=5-4=1
              72>71, pop 3, res[3]=5-3=2
              72<75, stack=[2,5]
i=6, temp=76: 76>72, pop 5, res[5]=6-5=1
              76>75, pop 2, res[2]=6-2=4
              stack=[6]
i=7, temp=73: 73<76, stack=[6,7]

最终结果：res = [1, 1, 4, 2, 1, 1, 0, 0]
```

## ⚡ 复杂度分析

- **时间复杂度**：O(n)
  - 虽然有嵌套循环（外层 `for` + 内层 `while`），但每个元素**最多入栈一次，出栈一次**
  - 总操作次数 = 2n = O(n)

- **空间复杂度**：O(n)
  - 栈的最大空间为 n（最坏情况下所有元素都入栈）

---

## 🔑 关键要点总结

### 1️⃣ 栈中存储索引而非元素值

```java
Stack<Integer> stack = new Stack<>();  // 存储索引
stack.push(i);  // 而不是 stack.push(nums[i])
```

**原因**：
- ✅ 方便计算距离：`i - prevIndex`
- ✅ 可以通过索引访问元素值：`nums[stack.peek()]`
- ✅ 同时保留位置和值的信息

### 2️⃣ 使用 while 循环不断弹出

```java
// ❌ 错误：只弹出一次
if (!stack.isEmpty() && condition) {
    stack.pop();
}

// ✅ 正确：循环弹出
while (!stack.isEmpty() && condition) {
    int index = stack.pop();
    // 处理 index
}
```

**原因**：当前元素可能是多个栈内元素的答案，需要全部弹出处理。

### 3️⃣ 理解栈的单调性

| 栈类型 | 栈内元素顺序 | 用途 | 弹出条件 |
|--------|-------------|------|----------|
| **单调递减栈** | 栈底 → 栈顶：大 → 小 | 找下一个更大元素 | `nums[i] > nums[stack.peek()]` |
| **单调递增栈** | 栈底 → 栈顶：小 → 大 | 找下一个更小元素 | `nums[i] < nums[stack.peek()]` |

**记忆技巧**：
- 找**更大**元素 → 用**递减**栈（遇到更大的就弹出）
- 找**更小**元素 → 用**递增**栈（遇到更小的就弹出）

### 4️⃣ 处理栈中剩余元素

遍历结束后，栈中剩余的元素表示**没有找到对应的答案**：
- 如果是"下一个更大元素"问题 → 之后没有更大的元素
- 如果是"下一个更小元素"问题 → 之后没有更小的元素

**处理方式**：结果数组初始化为默认值（通常是 -1 或 0），栈中剩余元素保持默认值即可。

### 5️⃣ 时间复杂度分析

虽然代码有嵌套循环（`for` + `while`），但时间复杂度仍为 **O(n)**：

```
每个元素最多执行以下操作各一次：
1. 入栈：push(i)     → n 次
2. 出栈：pop()       → n 次
总操作次数 = 2n = O(n)
```

这是**均摊分析**的结果：虽然内层 `while` 看起来可能执行多次，但所有元素的出栈总次数不会超过 n 次。

---

## 📌 LeetCode 相关题目

### 基础题（必做）

| 题号 | 题目 | 难度 | 类型 | 说明 |
|------|------|------|------|------|
| **739** | **每日温度** | 🟡 中等 | 下一个更大元素 | 单调栈入门题，找下一个更高温度 |
| 496 | 下一个更大元素 I | 🟢 简单 | 下一个更大元素 | 最基础的单调栈问题 |
| 503 | 下一个更大元素 II | 🟡 中等 | 循环数组 | 处理循环数组的技巧 |

### 进阶题

| 题号 | 题目 | 难度 | 类型 | 说明 |
|------|------|------|------|------|
| 84 | 柱状图中最大的矩形 | 🔴 困难 | 双向查找 | 找左右两边第一个更小的元素 |
| 42 | 接雨水 | 🔴 困难 | 双向查找 | 单调栈 + 双指针多种解法 |
| 316 | 去除重复字母 | 🟡 中等 | 单调栈 + 贪心 | 需要额外的去重逻辑 |
| 402 | 移掉 K 位数字 | 🟡 中等 | 单调栈 + 贪心 | 保持字典序最小 |
| 901 | 股票价格跨度 | 🟡 中等 | 下一个更大元素 | 在线算法，数据流处理 |

---

## 💡 进阶技巧

### 1. 循环数组处理

**问题**：如何处理循环数组（如 `[1,2,1]`，第三个 1 的下一个更大元素是 2）？

**解法**：遍历两遍数组（推荐）
```java
for (int i = 0; i < 2 * n; i++) {
    int index = i % n;
    // 使用 index 访问原数组
}
```

### 2. 单调栈 vs 双指针

**什么时候用单调栈？什么时候用双指针？**

| 算法 | 适用场景 | 时间复杂度 | 典型问题 |
|------|---------|-----------|---------|
| **单调栈** | 寻找"相邻关系"（下一个/上一个更大/更小） | O(n) | 每日温度、柱状图面积 |
| **双指针** | 两端夹逼、滑动窗口、快慢指针 | O(n) | 两数之和、移动零 |

**记忆**：
- 需要找"**下一个/上一个**"关系 → 单调栈
- 需要在区间内**双向移动**或**窗口滑动** → 双指针

---

## 🎯 学习路径建议

1. **第一步**：理解单调栈的基本原理
   - 为什么栈中存储索引？
   - 为什么用 `while` 循环弹出？
   - 栈的单调性是如何维护的？

2. **第二步**：掌握通用模板
   - 记住"下一个更大元素"的标准写法
   - 能够根据题目修改条件判断

3. **第三步**：练习基础题
   - LeetCode 496、739、503

4. **第四步**：挑战进阶题
   - LeetCode 84（柱状图最大矩形）
   - LeetCode 42（接雨水）

5. **第五步**：总结变形
   - 循环数组的处理
   - 双向查找的技巧
   - 结合贪心、哈希表等其他算法

---

## 📖 总结

单调栈是一种**优雅且高效**的数据结构：

✅ **优点**：
- 时间复杂度 O(n)，比暴力解法 O(n²) 快得多
- 代码简洁，模板化程度高
- 适用范围广，可以解决一大类问题

⚠️ **注意**：
- 必须存储索引而非元素值
- 必须用 `while` 循环弹出
- 理解栈的单调性和弹出条件

🎯 **关键**：
- **单调递减栈** → 找下一个**更大**元素
- **单调递增栈** → 找下一个**更小**元素

掌握单调栈模板后，你就拥有了解决"下一个更大/更小元素"问题的强大武器！💪

---

> **作者**: Dxboy266  
> **日期**: 2025-10-20  


# 二叉树核心模板 🌲

> 树是递归的天然载体。掌握三种遍历 + 两种递归模式，解决90%的树题。

---

## 🎯 递归三要素

1. **终止条件**：`root == null` 或叶子节点
2. **递归调用**：处理左右子树
3. **返回值**：向上传递什么信息

---

## 🔧 核心模板

### 1️⃣ 三种遍历（DFS）

```java
// 前序：根 → 左 → 右
public void preorder(TreeNode root) {
    if (root == null) return;
    visit(root);
    preorder(root.left);
    preorder(root.right);
}

// 中序：左 → 根 → 右 ⭐ BST中序遍历是有序的
public void inorder(TreeNode root) {
    if (root == null) return;
    inorder(root.left);
    visit(root);
    inorder(root.right);
}

// 后序：左 → 右 → 根 ⭐ 自底向上收集信息
public void postorder(TreeNode root) {
    if (root == null) return;
    postorder(root.left);
    postorder(root.right);
    visit(root);
}
```

**应用场景**：
- **前序**：复制树、序列化
- **中序**：BST排序、验证BST
- **后序**：删除树、计算高度/直径

### 2️⃣ 层序遍历（BFS）⭐⭐⭐

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int size = queue.size();  // ⭐ 记录当前层节点数
        List<Integer> level = new ArrayList<>();
        
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        result.add(level);
    }
    return result;
}
```

**关键**：`int size = queue.size()` 区分层级

---

### 3️⃣ 两种递归模式 ⭐⭐⭐

#### 模式一：自顶向下（前序思想）

```java
public void topDown(TreeNode root, int param) {
    if (root == null) return;
    
    doSomething(root, param);      // 先处理当前节点
    topDown(root.left, newParam);  // 向下传递参数
    topDown(root.right, newParam);
}
```

**应用**：路径问题、深度问题

#### 模式二：自底向上（后序思想）⭐⭐⭐

```java
public int bottomUp(TreeNode root) {
    if (root == null) return 0;
    
    int left = bottomUp(root.left);    // 先处理子树
    int right = bottomUp(root.right);
    
    return doSomething(left, right);   // 再处理当前层
}
```

**应用**：高度、直径、最近公共祖先

**示例：最大深度**
```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

**示例：二叉树直径**
```java
private int maxDiameter = 0;

public int diameterOfBinaryTree(TreeNode root) {
    maxDiameter = 0;
    depth(root);
    return maxDiameter;
}

private int depth(TreeNode root) {
    if (root == null) return 0;
    int left = depth(root.left);
    int right = depth(root.right);
    maxDiameter = Math.max(maxDiameter, left + right);  // 更新直径
    return Math.max(left, right) + 1;  // 返回深度
}
```

---

### 4️⃣ 特殊模式

#### BST验证（中序遍历 + 区间限制）

```java
// 方法1：中序遍历判断递增
public boolean isValidBST(TreeNode root) {
    List<Integer> inorder = new ArrayList<>();
    traverse(root, inorder);
    for (int i = 1; i < inorder.size(); i++) {
        if (inorder.get(i) <= inorder.get(i - 1)) return false;
    }
    return true;
}

// 方法2：区间限制 ⭐ 推荐
public boolean isValidBST(TreeNode root) {
    return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

private boolean isValid(TreeNode root, long min, long max) {
    if (root == null) return true;
    if (root.val <= min || root.val >= max) return false;
    return isValid(root.left, min, root.val) && 
           isValid(root.right, root.val, max);
}
```

#### 最近公共祖先（后序遍历）⭐⭐⭐

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    
    if (left != null && right != null) return root;  // 分别在两侧
    return left != null ? left : right;              // 都在一侧
}
```

#### 对称二叉树（双指针递归）

```java
public boolean isSymmetric(TreeNode root) {
    return isMirror(root.left, root.right);
}

private boolean isMirror(TreeNode left, TreeNode right) {
    if (left == null && right == null) return true;
    if (left == null || right == null) return false;
    return left.val == right.val && 
           isMirror(left.left, right.right) && 
           isMirror(left.right, right.left);
}
```

---

## 🔑 解题套路

### 看到什么题用什么方法

| 关键词 | 方法 | 示例 |
|--------|------|------|
| BST | 中序遍历 | 验证BST、第K小元素 |
| 深度/高度 | 后序遍历 | 最大深度、直径 |
| 祖先 | 后序遍历 | 最近公共祖先 |
| 对称/镜像 | 双指针递归 | 对称树、相同的树 |
| 层级/层序 | BFS队列 | 层序遍历、右视图 |
| 路径和 | 前序遍历 | 路径总和 |

### 递归返回值选择

- `void` → 只遍历（打印节点）
- `int/boolean` → 需要子树信息（深度、是否有效）
- `TreeNode` → 需要返回节点（构建树、找节点）

---

## 📌 已完成题目

| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|---------|
| 144 | 前序遍历 | 🟢 | 递归/栈 |
| 94 | 中序遍历 | 🟢 | 递归/栈 |
| 102 | 层序遍历 | 🟡 | BFS |
| 104 | 最大深度 | 🟢 | 后序递归 |
| 226 | 翻转二叉树 | 🟢 | 递归交换 |
| 101 | 对称二叉树 | 🟢 | 双指针递归 |
| 98 | 验证BST | 🟡 | 中序遍历/区间限制 |
| 236 | 最近公共祖先 | 🟡 | 后序递归 ⭐ |
| 543 | 二叉树的直径 | 🟢 | 后序递归 + 全局变量 |

---

## 💡 核心总结

**遍历选择**：
- 前序：根→左→右（复制、序列化）
- 中序：左→根→右（BST排序）⭐
- 后序：左→右→根（高度、删除）⭐
- 层序：BFS（层级问题）⭐

**递归模式**：
- 自顶向下：先处理根，再传递参数
- 自底向上：先处理子树，再组合结果 ⭐⭐⭐

**关键技巧**：
- BST → 中序遍历是有序的
- 层序 → `int size = queue.size()`
- 直径 → 后序遍历 + 全局变量
- LCA → 后序遍历，分情况讨论

掌握三种遍历 + 两种递归模式，解决90%的树题！🌲

---

> **作者**: Dxboy266  
> **更新**: 2025-10-27  
> **状态**: ✅ 树专题进阶完成（9/12题）


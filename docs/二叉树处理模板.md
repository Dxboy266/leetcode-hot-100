# 二叉树处理模板总结 🌲

> 二叉树是递归思想的最佳载体。掌握核心模板，树的问题迎刃而解。

---

## 📚 基础知识

### 二叉树节点定义

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 递归三要素

1. **终止条件**：何时停止递归（通常是 `root == null`）
2. **递归调用**：处理左右子树
3. **返回值**：当前层要返回什么

---

## 🔧 核心模板

### 1️⃣ 遍历模板

#### 前序遍历（根 → 左 → 右）

```java
public void preorder(TreeNode root) {
    if (root == null) return;
    
    visit(root);              // 访问根节点
    preorder(root.left);      // 遍历左子树
    preorder(root.right);     // 遍历右子树
}
```

#### 中序遍历（左 → 根 → 右）⭐

```java
public void inorder(TreeNode root) {
    if (root == null) return;
    
    inorder(root.left);       // 遍历左子树
    visit(root);              // 访问根节点
    inorder(root.right);      // 遍历右子树
}
```

**应用**：二叉搜索树的中序遍历结果是有序的

#### 后序遍历（左 → 右 → 根）

```java
public void postorder(TreeNode root) {
    if (root == null) return;
    
    postorder(root.left);     // 遍历左子树
    postorder(root.right);    // 遍历右子树
    visit(root);              // 访问根节点
}
```

#### 层序遍历（BFS）⭐⭐⭐

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int size = queue.size();  // 当前层的节点数
        List<Integer> level = new ArrayList<>();
        
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        
        result.add(level);
    }
    
    return result;
}
```

**关键点**：用 `size` 记录当前层的节点数，实现分层

---

### 2️⃣ 递归处理模板

#### 自顶向下（前序遍历思想）

```java
public void topDown(TreeNode root, int param) {
    if (root == null) return;
    
    // 在当前层处理
    doSomething(root, param);
    
    // 向下传递参数
    topDown(root.left, newParam);
    topDown(root.right, newParam);
}
```

**应用**：路径问题、深度问题

#### 自底向上（后序遍历思想）⭐⭐⭐

```java
public int bottomUp(TreeNode root) {
    if (root == null) return 0;
    
    // 先处理子树
    int left = bottomUp(root.left);
    int right = bottomUp(root.right);
    
    // 根据子树结果处理当前节点
    return doSomething(left, right);
}
```

**应用**：最大深度、判断平衡、最近公共祖先

**示例：最大深度**
```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    
    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);
    
    return Math.max(leftDepth, rightDepth) + 1;
}
```

---

### 3️⃣ 双指针递归（镜像/对称问题）

```java
public boolean isMirror(TreeNode left, TreeNode right) {
    // 终止条件
    if (left == null && right == null) return true;
    if (left == null || right == null) return false;
    
    // 当前层判断
    if (left.val != right.val) return false;
    
    // 递归判断子树（注意对称位置）
    return isMirror(left.left, right.right) && 
           isMirror(left.right, right.left);
}
```

**应用**：对称二叉树、相同的树

---

### 4️⃣ 树的修改模板

#### 翻转二叉树

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    
    // 递归翻转左右子树
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);
    
    // 交换左右子树
    root.left = right;
    root.right = left;
    
    return root;
}
```

#### 构建二叉树

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    // 使用哈希表存储中序遍历的索引
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    
    return build(preorder, 0, preorder.length - 1,
                 inorder, 0, inorder.length - 1, map);
}

private TreeNode build(int[] preorder, int preStart, int preEnd,
                       int[] inorder, int inStart, int inEnd,
                       Map<Integer, Integer> map) {
    if (preStart > preEnd) return null;
    
    // 前序遍历的第一个节点是根节点
    int rootVal = preorder[preStart];
    TreeNode root = new TreeNode(rootVal);
    
    // 在中序遍历中找到根节点位置
    int rootIndex = map.get(rootVal);
    int leftSize = rootIndex - inStart;
    
    // 递归构建左右子树
    root.left = build(preorder, preStart + 1, preStart + leftSize,
                      inorder, inStart, rootIndex - 1, map);
    root.right = build(preorder, preStart + leftSize + 1, preEnd,
                       inorder, rootIndex + 1, inEnd, map);
    
    return root;
}
```

---

### 5️⃣ 迭代遍历（使用栈）

#### 中序遍历迭代版

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode curr = root;
    
    while (curr != null || !stack.isEmpty()) {
        // 一直向左走到底
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        
        // 弹出并访问
        curr = stack.pop();
        result.add(curr.val);
        
        // 转向右子树
        curr = curr.right;
    }
    
    return result;
}
```

---

## 🔑 关键技巧

### 1. 递归终止条件

```java
// 空节点
if (root == null) return ...;

// 叶子节点
if (root.left == null && root.right == null) return ...;

// 单子节点
if (root.left == null) return ...;
if (root.right == null) return ...;
```

### 2. 递归返回值设计

- **void**：只遍历，不需要返回值（如打印）
- **int/boolean**：需要子树信息（如深度、是否平衡）
- **TreeNode**：需要返回节点（如构建树、找节点）

### 3. 层序遍历的关键

```java
int size = queue.size();  // ⭐ 记录当前层节点数
for (int i = 0; i < size; i++) {
    // 处理当前层
}
```

### 4. 二叉搜索树（BST）性质

- 中序遍历结果是升序
- 左子树所有节点 < 根节点 < 右子树所有节点

---

## 📌 已完成题目

| 题号 | 题目 | 难度 | 核心技巧 |
|------|------|------|---------|
| 104 | 二叉树的最大深度 | 🟢 简单 | 自底向上递归 |
| 226 | 翻转二叉树 | 🟢 简单 | 递归交换子树 |
| 94 | 二叉树的中序遍历 | 🟢 简单 | 递归/迭代（栈） |
| 101 | 对称二叉树 | 🟢 简单 | 双指针递归 |
| 102 | 二叉树的层序遍历 | 🟡 中等 | BFS（队列） |

---

## 📖 总结

**核心思想**：
1. **递归** - 树的天然特性，先处理子树再处理根
2. **分治** - 大问题分解为子问题（左子树 + 右子树）
3. **BFS** - 层序遍历使用队列
4. **DFS** - 深度优先使用递归或栈

**解题模板**：
1. **遍历问题** → 前/中/后序遍历
2. **深度/高度** → 自底向上递归
3. **对称/镜像** → 双指针递归
4. **层级问题** → BFS层序遍历
5. **路径问题** → 自顶向下递归

**递归技巧**：
- 明确递归函数的定义
- 确定终止条件
- 处理当前层逻辑
- 递归调用左右子树
- 返回结果

**注意事项**：
- 空节点判断要放在最前面
- 理解前序/中序/后序的区别
- BFS 要记录每层的节点数
- 递归时注意参数传递

掌握这些模板，二叉树题目手到擒来！🌲

---

> **作者**: Dxboy266  
> **完成日期**: 2025-10-26  
> **状态**: ✅ 二叉树入门题目完成


# 链表处理模板总结 🔗

> **链表（Linked List）** 是一种基础的数据结构，由节点组成，每个节点包含数据和指向下一个节点的指针。  
> 掌握链表的核心技巧和常见模板，是解决链表题目的关键。

---

## 📚 链表基础知识

### 链表节点定义

```java
public class ListNode {
    int val;
    ListNode next;
    
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { 
        this.val = val; 
        this.next = next; 
    }
}
```

### 链表 vs 数组

| 特性 | 数组 | 链表 |
|------|------|------|
| 内存分配 | 连续 | 不连续 |
| 随机访问 | O(1) | O(n) |
| 插入/删除（已知位置） | O(n) | O(1) |
| 空间利用 | 固定大小 | 动态增长 |
| 缓存友好 | ✅ 是 | ❌ 否 |

---

## 🔧 核心模板

### 1️⃣ 虚拟头节点（Dummy Head）⭐

**适用场景**：需要修改头节点或创建新链表时

**核心思想**：创建一个哑节点，简化边界处理

```java
public ListNode processLinkedList(ListNode head) {
    // 创建虚拟头节点
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    
    // 使用 current 指针遍历/操作
    ListNode current = dummy;
    
    while (current.next != null) {
        // 处理 current.next
        current = current.next;
    }
    
    // 返回真正的头节点
    return dummy.next;
}
```

**典型题目**：
- ✅ [2. 两数相加](../src/main/java/com/leetcode/linkedlist/AddTwoNumbers.java)
- ✅ [19. 删除链表的倒数第 N 个结点](../src/main/java/com/leetcode/linkedlist/RemoveNthFromEnd.java)
- ✅ [21. 合并两个有序链表](../src/main/java/com/leetcode/linkedlist/MergeTwoSortedLists.java)
- ✅ [24. 两两交换链表中的节点](../src/main/java/com/leetcode/linkedlist/SwapPairs.java)

---

### 2️⃣ 快慢指针（双指针）⭐⭐⭐

**适用场景**：找中点、检测环、找倒数第 k 个节点

#### 2.1 找链表中点

```java
public ListNode findMiddle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    // fast 走两步，slow 走一步
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;  // slow 指向中点
}
```

**关键点**：
- 奇数节点：`fast.next == null` 时停止，slow 指向唯一中点
- 偶数节点：`fast == null` 时停止，slow 指向第二个中点

**典型题目**：
- ✅ [234. 回文链表](../src/main/java/com/leetcode/linkedlist/IsPalindrome.java)
- ✅ [876. 链表的中间结点](../src/main/java/com/leetcode/linkedlist/MiddleNode.java)

#### 2.2 检测环（Floyd 判圈算法）

```java
public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            return true;  // 相遇说明有环
        }
    }
    
    return false;
}
```

**为什么一定会相遇？**
- 假设环的长度为 L
- 当慢指针进入环时，快指针已经在环内某个位置
- 每次迭代，快慢指针之间的距离减少 1
- 所以最多 L 次迭代后，两指针会相遇

**典型题目**：
- ✅ [141. 环形链表](../src/main/java/com/leetcode/linkedlist/HasCycle.java)

#### 2.3 找环的入口 ⭐⭐⭐

```java
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    // 1. 快慢指针找到相遇点
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            // 2. 从头节点和相遇点同时出发
            ListNode ptr1 = head;
            ListNode ptr2 = slow;
            
            while (ptr1 != ptr2) {
                ptr1 = ptr1.next;
                ptr2 = ptr2.next;
            }
            
            // 3. 再次相遇的地方就是环的入口
            return ptr1;
        }
    }
    
    return null;  // 无环
}
```

**数学证明**：
- 设链表头到环入口的距离为 a
- 设环入口到相遇点的距离为 b
- 设相遇点到环入口的距离为 c
- 相遇时，慢指针走了 a + b，快指针走了 a + b + n(b + c)
- 因为快指针速度是慢指针的 2 倍：2(a + b) = a + b + n(b + c)
- 化简得：a = (n-1)(b + c) + c
- **结论**：从头节点和相遇点同时出发，再次相遇的地方就是环的入口！

**典型题目**：
- ✅ [142. 环形链表 II](../src/main/java/com/leetcode/linkedlist/DetectCycle.java)

#### 2.4 找倒数第 k 个节点

```java
public ListNode findKthFromEnd(ListNode head, int k) {
    ListNode fast = head;
    ListNode slow = head;
    
    // fast 先走 k 步
    for (int i = 0; i < k; i++) {
        if (fast == null) return null;
        fast = fast.next;
    }
    
    // fast 和 slow 一起走
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    
    return slow;  // slow 指向倒数第 k 个节点
}
```

**关键技巧**：
- 快指针先走 k 步，形成间隔
- 两指针同速前进，当快指针到达末尾时，慢指针正好在倒数第 k 个位置
- **删除倒数第 k 个节点**：让快指针先走 k+1 步，慢指针停在待删除节点的前一个

**典型题目**：
- ✅ [19. 删除链表的倒数第 N 个结点](../src/main/java/com/leetcode/linkedlist/RemoveNthFromEnd.java)

#### 2.5 找两个链表的相交节点 ⭐⭐⭐

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    
    ListNode pA = headA;
    ListNode pB = headB;
    
    // 让两个指针走相同的路径长度
    // pA 走完 A 后，从 B 的头开始
    // pB 走完 B 后，从 A 的头开始
    while (pA != pB) {
        pA = (pA == null) ? headB : pA.next;
        pB = (pB == null) ? headA : pB.next;
    }
    
    // 返回相交节点（如果不相交，最终 pA == pB == null）
    return pA;
}
```

**核心思想**：
- pA 走的路径：a (独有) + c (公共) + b (独有)
- pB 走的路径：b (独有) + c (公共) + a (独有)
- 路径长度相同，所以会在相交点相遇
- 如果不相交，最终都会变成 null

**浪漫解读**：
你走过我走过的路，我走过你走过的路，我们终会在某处相遇 ❤️

**典型题目**：
- ✅ [160. 相交链表](../src/main/java/com/leetcode/linkedlist/GetIntersectionNode.java)

---

### 3️⃣ 反转链表（三指针法）⭐

**适用场景**：反转整个链表或部分链表

**核心思想**：使用三个指针逐个反转节点指向

```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;  // 前驱节点
    ListNode curr = head;  // 当前节点
    
    while (curr != null) {
        ListNode next = curr.next;  // 保存下一个节点
        curr.next = prev;           // 反转指针
        prev = curr;                // 移动 prev
        curr = next;                // 移动 curr
    }
    
    return prev;  // prev 是新的头节点
}
```

**图解**：
```
原链表：1 → 2 → 3 → null
步骤1：null ← 1   2 → 3 → null
步骤2：null ← 1 ← 2   3 → null
步骤3：null ← 1 ← 2 ← 3
```

**递归写法**：
```java
public ListNode reverseListRecursive(ListNode head) {
    // 递归终止条件
    if (head == null || head.next == null) {
        return head;
    }
    
    // 递归处理后面的链表
    ListNode newHead = reverseListRecursive(head.next);
    
    // 回溯时处理当前节点
    head.next.next = head;
    head.next = null;
    
    return newHead;
}
```

**典型题目**：
- ✅ [206. 反转链表](../src/main/java/com/leetcode/linkedlist/ReverseList.java)
- ✅ [234. 回文链表](../src/main/java/com/leetcode/linkedlist/IsPalindrome.java)（反转后半部分）
- [ ] 25. K 个一组翻转链表（困难）

---

### 4️⃣ 合并链表

**适用场景**：合并两个或多个有序链表

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    // 连接剩余部分
    current.next = (l1 != null) ? l1 : l2;
    
    return dummy.next;
}
```

**典型题目**：
- ✅ [21. 合并两个有序链表](../src/main/java/com/leetcode/linkedlist/MergeTwoSortedLists.java)
- [ ] 23. 合并 K 个升序链表（困难）

---

## 🔑 关键技巧总结

### 1️⃣ 边界条件处理

```java
// 空链表
if (head == null) return null;

// 单节点链表
if (head.next == null) return head;

// 检查 next 是否为 null
if (curr.next != null) {
    // 安全访问 curr.next
}
```

### 2️⃣ 保存临时节点

```java
// 在改变 next 指针前，先保存下一个节点
ListNode next = curr.next;
curr.next = prev;  // 现在可以安全地改变指针
curr = next;       // 继续遍历
```

### 3️⃣ 循环条件选择

```java
// 遍历到最后一个节点
while (curr.next != null) {
    curr = curr.next;
}

// 遍历所有节点（包括 null）
while (curr != null) {
    curr = curr.next;
}

// 快慢指针
while (fast != null && fast.next != null) {
    // 确保 fast.next.next 不会空指针
}
```

### 4️⃣ 虚拟头节点的使用时机

**使用虚拟头节点的情况**：
- ✅ 头节点可能被删除
- ✅ 需要创建新链表
- ✅ 需要在头部插入节点

**不需要虚拟头节点**：
- ❌ 只是遍历链表
- ❌ 头节点不会改变

---

## 🎯 解题思路流程图

```
遇到链表题目
    ↓
是否需要修改头节点/创建新链表？
    ├─ 是 → 使用虚拟头节点
    └─ 否 → 直接操作
         ↓
是否需要找中点/检测环/倒数第k个？
    ├─ 是 → 使用快慢指针
    └─ 否 → 继续判断
         ↓
是否需要反转链表？
    ├─ 是 → 三指针迭代 或 递归
    └─ 否 → 继续判断
         ↓
是否需要合并链表？
    ├─ 是 → 双指针 + 虚拟头节点
    └─ 否 → 根据具体问题设计算法
```

---

## 📌 LeetCode 链表专题

### 基础题（必做）✅

| 题号 | 题目 | 难度 | 核心技巧 | 状态 |
|------|------|------|---------|------|
| **2** | **两数相加** | 🟡 中等 | 虚拟头节点 + 进位 | ✅ 已完成 |
| **19** | **删除链表的倒数第 N 个结点** | 🟡 中等 | 快慢指针间隔 | ✅ 已完成 |
| **21** | **合并两个有序链表** | 🟢 简单 | 虚拟头节点 + 双指针 | ✅ 已完成 |
| **24** | **两两交换链表中的节点** | 🟡 中等 | 虚拟头节点 / 递归 | ✅ 已完成 |
| **141** | **环形链表** | 🟢 简单 | Floyd 判圈算法 | ✅ 已完成 |
| **142** | **环形链表 II** | 🟡 中等 | 快慢指针 + 数学推导 | ✅ 已完成 |
| **160** | **相交链表** | 🟢 简单 | 路径对齐技巧 | ✅ 已完成 |
| **206** | **反转链表** | 🟢 简单 | 三指针 / 递归 | ✅ 已完成 |
| **234** | **回文链表** | 🟢 简单 | 快慢指针 + 反转 | ✅ 已完成 |
| **876** | **链表的中间结点** | 🟢 简单 | 快慢指针 | ✅ 已完成 |

### 进阶题（挑战）

| 题号 | 题目 | 难度 | 核心技巧 | 状态 |
|------|------|------|---------|------|
| 138 | 随机链表的复制 | 🟡 中等 | 哈希表 / 原地复制 | ⏳ 待完成 |
| 146 | LRU 缓存 | 🟡 中等 | 哈希表 + 双向链表 | ⏳ 待完成 |
| 148 | 排序链表 | 🟡 中等 | 归并排序 | ⏳ 待完成 |
| 23 | 合并K个升序链表 | 🔴 困难 | 优先队列 / 分治 | ⏳ 待完成 |
| 25 | K 个一组翻转链表 | 🔴 困难 | 反转链表变形 | ⏳ 待完成 |

---

## 💡 学习建议

### 阶段一：掌握基础操作
1. 熟练使用 while 循环遍历链表
2. 掌握节点创建和指针修改
3. 重视 null 检查和边界处理

### 阶段二：熟练核心模板
1. **虚拟头节点**：简化头节点处理
2. **快慢指针**：找中点、检测环、倒数第k个
3. **三指针反转**：反转链表的核心

### 阶段三：练习基础题
1. 206. 反转链表（迭代 + 递归）
2. 21. 合并两个有序链表
3. 141/142. 环形链表 I & II
4. 160. 相交链表

### 阶段四：综合应用
1. 234. 回文链表（快慢指针 + 反转）
2. 19. 删除倒数第 N 个节点
3. 24. 两两交换链表中的节点

---

## 📖 总结

链表题目的核心在于：

✅ **指针操作**：
- 熟练修改 next 指针
- 注意保存临时节点
- 避免链表断裂

✅ **常用技巧**：
- **虚拟头节点**（Dummy Head）：简化头节点处理
- **快慢指针**（Fast & Slow Pointers）：找中点、检测环、倒数第k个
- **三指针反转**（prev, curr, next）：反转链表的标准写法
- **路径对齐**：两个链表相交问题的巧妙解法

✅ **边界处理**：
- 空链表：`head == null`
- 单节点链表：`head.next == null`
- 两个节点的链表

**记住**：
1. 需要修改头节点 → 虚拟头节点
2. 需要找位置关系 → 快慢指针
3. 需要反转 → 三指针法
4. 保存临时节点 → 防止链表断裂

掌握这些模板后，大部分链表题都能轻松解决！💪

---

> **作者**: Dxboy266  
> **日期**: 2025-10-21  
> **更新**: 2025-10-24 - 增加删除倒数节点、回文链表、链表中点

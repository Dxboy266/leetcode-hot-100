# 链表处理模板总结 🔗

> **链表（Linked List）** 是一种基础的数据结构，由节点组成，每个节点包含数据和指向下一个节点的指针。  
> 掌握链表的基本操作和常见模板，是解决链表题目的关键。

---

## 📚 链表基础知识

### 链表节点定义

```java
public class ListNode {
    int val;
    ListNode next;
    
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { 
        this.val = val; 
        this.next = next; 
    }
}
```

### 链表 vs 数组

| 特性 | 数组 | 链表 |
|------|------|------|
| 内存分配 | 连续 | 不连续 |
| 随机访问 | O(1) | O(n) |
| 插入/删除（已知位置） | O(n) | O(1) |
| 空间利用 | 固定大小 | 动态增长 |
| 缓存友好 | ✅ 是 | ❌ 否 |

---

## 🔧 核心模板

### 1️⃣ 虚拟头节点（Dummy Head）

**适用场景**：需要修改头节点或创建新链表时

**核心思想**：创建一个哑节点，简化边界处理

```java
public ListNode processLinkedList(ListNode head) {
    // 创建虚拟头节点
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    
    // 使用 current 指针遍历/操作
    ListNode current = dummy;
    
    while (current.next != null) {
        // 处理 current.next
        current = current.next;
    }
    
    // 返回真正的头节点
    return dummy.next;
}
```

**典型题目**：
- ✅ [2. 两数相加](../src/main/java/com/leetcode/linkedlist/AddTwoNumbers.java)
- ✅ [21. 合并两个有序链表](../src/main/java/com/leetcode/linkedlist/MergeTwoSortedLists.java)
- ✅ [24. 两两交换链表中的节点](../src/main/java/com/leetcode/linkedlist/SwapPairs.java)

---

### 2️⃣ 反转链表（三指针法）

**适用场景**：反转整个链表或部分链表

**核心思想**：使用三个指针逐个反转节点指向

```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;  // 前驱节点
    ListNode curr = head;  // 当前节点
    
    while (curr != null) {
        ListNode next = curr.next;  // 保存下一个节点
        curr.next = prev;           // 反转指针
        prev = curr;                // 移动 prev
        curr = next;                // 移动 curr
    }
    
    return prev;  // prev 是新的头节点
}
```

**图解**：
```
原链表：1 → 2 → 3 → null
步骤1：null ← 1   2 → 3 → null
步骤2：null ← 1 ← 2   3 → null
步骤3：null ← 1 ← 2 ← 3
```

**典型题目**：
- ✅ [206. 反转链表](../src/main/java/com/leetcode/linkedlist/ReverseList.java)
- [ ] 234. 回文链表（反转后半部分）
- [ ] 25. K 个一组翻转链表（Hard）

---

### 3️⃣ 快慢指针（双指针）

**适用场景**：找中点、检测环、找倒数第 k 个节点

#### 3.1 找链表中点

```java
public ListNode findMiddle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    // fast 走两步，slow 走一步
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;  // slow 指向中点
}
```

**变体**：
- `fast.next != null`：链表长度为偶数时，返回后半部分的第一个节点
- `fast != null`：链表长度为偶数时，返回前半部分的最后一个节点

#### 3.2 检测环（Floyd 判圈算法）⭐

```java
public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            return true;  // 相遇说明有环
        }
    }
    
    return false;
}
```

**为什么一定会相遇？**
- 假设环的长度为 L
- 当慢指针进入环时，快指针已经在环内某个位置
- 每次迭代，快慢指针之间的距离减少 1
- 所以最多 L 次迭代后，两指针会相遇

#### 3.2.5 找环的入口（重要）⭐⭐⭐

```java
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    // 1. 快慢指针找到相遇点
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            // 2. 从头节点和相遇点同时出发
            ListNode ptr1 = head;
            ListNode ptr2 = slow;
            
            while (ptr1 != ptr2) {
                ptr1 = ptr1.next;
                ptr2 = ptr2.next;
            }
            
            // 3. 再次相遇的地方就是环的入口
            return ptr1;
        }
    }
    
    return null;  // 无环
}
```

**数学证明**：
- 设链表头到环入口的距离为 a
- 设环入口到相遇点的距离为 b
- 设相遇点到环入口的距离为 c
- 相遇时，慢指针走了 a + b，快指针走了 a + b + n(b + c)
- 因为快指针速度是慢指针的 2 倍：2(a + b) = a + b + n(b + c)
- 化简得：a = (n-1)(b + c) + c
- **结论**：从头节点和相遇点同时出发，再次相遇的地方就是环的入口！

#### 3.3 找倒数第 k 个节点

```java
public ListNode findKthFromEnd(ListNode head, int k) {
    ListNode fast = head;
    ListNode slow = head;
    
    // fast 先走 k 步
    for (int i = 0; i < k; i++) {
        if (fast == null) return null;
        fast = fast.next;
    }
    
    // fast 和 slow 一起走
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    
    return slow;  // slow 指向倒数第 k 个节点
}
```

#### 3.4 找两个链表的相交节点⭐⭐⭐

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    // 边界情况
    if (headA == null || headB == null) {
        return null;
    }
    
    ListNode pA = headA;
    ListNode pB = headB;
    
    // 让两个指针走相同的路径长度
    // pA 走完 A 后，从 B 的头开始
    // pB 走完 B 后，从 A 的头开始
    while (pA != pB) {
        pA = (pA == null) ? headB : pA.next;
        pB = (pB == null) ? headA : pB.next;
    }
    
    // 返回相交节点（如果不相交，最终 pA == pB == null）
    return pA;
}
```

**核心思想**：
- pA 走的路径：a (独有) + c (公共) + b (独有)
- pB 走的路径：b (独有) + c (公共) + a (独有)
- 路径长度相同，所以会在相交点相遇
- 如果不相交，最终都会变成 null

**浪漫解读**：
你走过我走过的路，我走过你走过的路，我们终会在某处相遇 ❤️

**典型题目**：
- ✅ [141. 环形链表](../src/main/java/com/leetcode/linkedlist/HasCycle.java)
- ✅ [142. 环形链表 II](../src/main/java/com/leetcode/linkedlist/DetectCycle.java)
- ✅ [160. 相交链表](../src/main/java/com/leetcode/linkedlist/GetIntersectionNode.java)
- [ ] 19. 删除链表的倒数第 N 个结点
- [ ] 876. 链表的中间结点

---

### 4️⃣ 递归处理链表

**适用场景**：需要从后往前处理链表

**核心思想**：先递归到末尾，再在回溯过程中处理

```java
public ListNode reverseListRecursive(ListNode head) {
    // 递归终止条件
    if (head == null || head.next == null) {
        return head;
    }
    
    // 递归处理后面的链表
    ListNode newHead = reverseListRecursive(head.next);
    
    // 回溯时处理当前节点
    head.next.next = head;
    head.next = null;
    
    return newHead;
}
```

**递归三要素**：
1. **终止条件**：`head == null` 或 `head.next == null`
2. **递归调用**：处理子问题
3. **本层处理**：处理当前节点与子问题的关系

**典型题目**：
- ✅ [206. 反转链表（递归）](../src/main/java/com/leetcode/linkedlist/ReverseList.java)
- ✅ [21. 合并两个有序链表（递归）](../src/main/java/com/leetcode/linkedlist/MergeTwoSortedLists.java)

---

### 5️⃣ 合并链表

**适用场景**：合并两个或多个有序链表

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(-1);
    ListNode current = dummy;
    
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    // 连接剩余部分
    current.next = (l1 != null) ? l1 : l2;
    
    return dummy.next;
}
```

**典型题目**：
- ✅ [21. 合并两个有序链表](../src/main/java/com/leetcode/linkedlist/MergeTwoSortedLists.java)
- [ ] 23. 合并 K 个升序链表

---

## 🔑 关键技巧总结

### 1️⃣ 边界条件处理

```java
// 空链表
if (head == null) return null;

// 单节点链表
if (head.next == null) return head;

// 检查 next 是否为 null
if (curr.next != null) {
    // 安全访问 curr.next
}
```

### 2️⃣ 保存临时节点

```java
// 在改变 next 指针前，先保存下一个节点
ListNode next = curr.next;
curr.next = prev;  // 现在可以安全地改变指针
curr = next;       // 继续遍历
```

### 3️⃣ 循环条件选择

```java
// 遍历到最后一个节点
while (curr.next != null) {
    curr = curr.next;
}

// 遍历所有节点（包括 null）
while (curr != null) {
    curr = curr.next;
}

// 快慢指针
while (fast != null && fast.next != null) {
    // 确保 fast.next.next 不会空指针
}
```

### 4️⃣ 虚拟头节点的使用时机

**使用虚拟头节点的情况**：
- ✅ 头节点可能被删除
- ✅ 需要创建新链表
- ✅ 需要在头部插入节点

**不需要虚拟头节点**：
- ❌ 只是遍历链表
- ❌ 头节点不会改变

---

## 📝 常见问题和解决方案

### 问题 1：如何判断链表有环？

**方法**：快慢指针（Floyd 判圈算法）
- 快指针每次走 2 步
- 慢指针每次走 1 步
- 如果有环，两指针一定会相遇

### 问题 2：如何找到环的入口？

**方法**：相遇后，一个指针回到头节点，两指针同速前进
```java
// 第一次相遇后
ListNode ptr1 = head;
ListNode ptr2 = slow;  // slow 是第一次相遇的位置

while (ptr1 != ptr2) {
    ptr1 = ptr1.next;
    ptr2 = ptr2.next;
}

return ptr1;  // 环的入口
```

### 问题 3：如何判断回文链表？

**方法**：快慢指针找中点 + 反转后半部分 + 比较
1. 用快慢指针找到中点
2. 反转后半部分链表
3. 比较前半部分和后半部分
4. （可选）恢复链表

---

## 🎯 解题思路流程图

```
遇到链表题目
    ↓
是否需要修改头节点/创建新链表？
    ├─ 是 → 使用虚拟头节点
    └─ 否 → 直接操作
         ↓
是否需要找中点/检测环/倒数第k个？
    ├─ 是 → 使用快慢指针
    └─ 否 → 继续判断
         ↓
是否需要反转链表？
    ├─ 是 → 三指针迭代 或 递归
    └─ 否 → 继续判断
         ↓
是否需要合并链表？
    ├─ 是 → 双指针 + 虚拟头节点
    └─ 否 → 根据具体问题设计算法
```

---

## 📌 LeetCode 链表专题

### 基础题（必做）

| 题号 | 题目 | 难度 | 模板 | 说明 |
|------|------|------|------|------|
| **206** | **反转链表** | 🟢 简单 | 三指针 / 递归 | 链表基础，必须掌握 |
| **21** | **合并两个有序链表** | 🟢 简单 | 虚拟头节点 | 双指针合并 |
| **2** | **两数相加** | 🟡 中等 | 虚拟头节点 | 模拟竖式加法 |
| **141** | **环形链表** | 🟢 简单 | 快慢指针 | Floyd 判圈算法 |
| **160** | **相交链表** | 🟢 简单 | 双指针 | 路径对齐技巧 |
| **24** | **两两交换链表中的节点** | 🟡 中等 | 虚拟头节点 / 递归 | 指针操作 |

### 进阶题

| 题号 | 题目 | 难度 | 模板 | 说明 |
|------|------|------|------|------|
| **142** | **环形链表 II** | 🟡 中等 | 快慢指针 | 找环的入口（重要） |
| 19 | 删除链表的倒数第 N 个结点 | 🟡 中等 | 快慢指针 | 双指针间隔 |
| 234 | 回文链表 | 🟢 简单 | 快慢指针 + 反转 | 综合应用 |
| 148 | 排序链表 | 🟡 中等 | 归并排序 | O(n log n) 时间，O(1) 空间 |
| 23 | 合并K个升序链表 | 🔴 困难 | 优先队列 | 多路归并 |
| 25 | K 个一组翻转链表 | 🔴 困难 | 反转链表 | Hard，挑战题 |

---

## 💡 学习建议

### 第一步：掌握基础操作

1. **遍历链表**：熟练使用 while 循环
2. **创建节点**：new ListNode(val)
3. **修改指针**：node.next = newNode
4. **边界处理**：null 检查

### 第二步：熟练模板

1. **虚拟头节点**：简化头节点处理
2. **快慢指针**：找中点、检测环
3. **三指针反转**：反转链表的核心

### 第三步：练习基础题

1. 206. 反转链表（两种方法都要会）
2. 21. 合并两个有序链表
3. 141. 环形链表
4. 160. 相交链表

### 第四步：综合应用

1. 234. 回文链表（快慢指针 + 反转）
2. 19. 删除倒数第 N 个节点
3. 142. 环形链表 II

---

## 📖 总结

链表题目的核心在于：

✅ **指针操作**：
- 熟练修改 next 指针
- 注意保存临时节点
- 避免链表断裂

✅ **常用技巧**：
- 虚拟头节点（Dummy Head）
- 快慢指针（Fast & Slow Pointers）
- 三指针反转（prev, curr, next）

✅ **边界处理**：
- 空链表
- 单节点链表
- 两个节点的链表

掌握这些模板后，大部分链表题都能轻松解决！💪

---

> **作者**: Dxboy266  
> **日期**: 2025-10-21  
> **更新**: 基于 LeetCode 链表专题总结



# 前缀和 + 哈希表 模板

## 📖 核心思想

前缀和 + 哈希表是解决**子数组和问题**的经典模板，可以将 O(n²) 的暴力解法优化到 O(n)。

## 🔑 核心公式

```
子数组和：sum[i,j] = prefixSum[j] - prefixSum[i-1]
如果 sum[i,j] = k，则：prefixSum[i-1] = prefixSum[j] - k
```

## 📝 标准模板

```java
public int subarraySum(int[] nums, int k) {
    int count = 0;
    int prefixSum = 0;  // 当前前缀和
    Map<Integer, Integer> countMap = new HashMap<>();
    
    // 关键：初始化 prefixSum[0] = 0，出现次数为1
    countMap.put(0, 1);
    
    for (int num : nums) {
        // 1. 计算当前前缀和
        prefixSum += num;
        
        // 2. 查找是否存在 prefixSum - k 的前缀和
        if (countMap.containsKey(prefixSum - k)) {
            count += countMap.get(prefixSum - k);
        }
        
        // 3. 将当前前缀和加入HashMap
        countMap.put(prefixSum, countMap.getOrDefault(prefixSum, 0) + 1);
    }
    
    return count;
}
```

## 🎯 适用场景

1. **子数组和等于目标值**：LeetCode 560
2. **子数组和能被K整除**：LeetCode 974
3. **连续子数组和**：LeetCode 523
4. **和为S的连续正数序列**：剑指Offer 57-II

## 💡 关键点

### 1. 初始化
```java
countMap.put(0, 1);  // 处理从索引0开始的子数组
```

### 2. 查找顺序
```java
// 先查找，再更新
if (countMap.containsKey(prefixSum - k)) {
    count += countMap.get(prefixSum - k);
}
countMap.put(prefixSum, countMap.getOrDefault(prefixSum, 0) + 1);
```

### 3. 为什么先查找再更新？
- 避免将当前元素自己算作子数组
- 确保查找的是**之前**出现的前缀和

## 🔍 算法分析

| 方面 | 复杂度 | 说明 |
|------|--------|------|
| 时间复杂度 | O(n) | 只需遍历一次数组 |
| 空间复杂度 | O(n) | HashMap存储前缀和 |
| 查找效率 | O(1) | HashMap查找 |

## 📚 相关题目

### 基础题
- [560. 和为K的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
- [1. 两数之和](https://leetcode.cn/problems/two-sum/)

### 进阶题
- [974. 和可被K整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)
- [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)
- [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/)

## ⚠️ 易错点

1. **忘记初始化**：`countMap.put(0, 1)`
2. **查找顺序错误**：应该先查找再更新
3. **理解子数组**：必须是连续的，不是子序列
4. **负数处理**：数组元素可能为负数，前缀和可能重复

## 🚀 优化技巧

1. **空间优化**：不需要存储完整的前缀和数组，只需当前前缀和
2. **边界处理**：考虑空数组、单元素等边界情况
3. **重复前缀和**：用HashMap记录出现次数，而不是简单的存在性

---

**总结**：前缀和+哈希表模板是解决子数组和问题的利器，掌握这个模板可以轻松解决一大类相关问题！


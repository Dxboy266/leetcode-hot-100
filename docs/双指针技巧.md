# 双指针技巧总结

## 核心思想

使用两个指针在数组或链表中进行遍历，根据移动方向和速度分为：
- **快慢指针**：同向移动，速度不同
- **左右指针**：相向移动，从两端向中间

## 实战经验

### 1. 快慢指针 - 原地修改数组

**相关题目**：[283.移动零](../src/main/java/com/leetcode/array/MoveZeroes.java)

**核心模板**：
```java
int slow = 0;  // 指向下一个要放置元素的位置
for (int fast = 0; fast < nums.length; fast++) {
    if (满足条件) {
        nums[slow] = nums[fast];
        slow++;
    }
}
```

**关键点**：
- slow指针指向处理后的数组末尾
- fast指针遍历整个数组
- 保持元素的相对顺序

**易错点**：
- 忘记检查 `slow != fast` 可能导致不必要的赋值
- 边界条件：数组为空或只有一个元素

### 2. 哈希表优化（相关）

**相关题目**：[1.两数之和](../src/main/java/com/leetcode/array/TwoSum.java)

**核心经验**：
- 一次遍历优于两次遍历
- 边遍历边查找，用HashMap存储{元素值: 索引}
- 时间复杂度：O(n²) → O(n)

## 性能对比（实测数据）

以283.移动零为例：
- 双指针交换：244500 ns
- 两次遍历：195300 ns ⭐ **更快**
- 冒泡思想：23618500 ns

**启示**：理论最优 ≠ 实际最优，简单的循环结构更适合CPU优化

## 总结

1. **何时使用**：需要O(1)空间复杂度、原地修改数组
2. **初始化**：slow = 0, fast = 0（或根据题意调整）
3. **循环条件**：`while (fast < length)`
4. **优化技巧**：条件判断减少不必要的赋值操作


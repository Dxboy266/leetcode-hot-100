# 哈希表分组技巧总结

## 核心思想

利用HashMap的key-value特性，将具有相同特征的元素归为一组。
**关键**：设计合适的key，使相同特征的元素映射到同一个key。

## 实战经验

### 1. 排序作为key

**相关题目**：[49.字母异位词分组](../src/main/java/com/leetcode/string/GroupAnagrams.java)

**核心思路**：
- 将字符串排序后作为key
- 例如："eat"、"tea"、"ate" → 排序后都是 "aet"
- 时间复杂度：O(nk log k)

**关键代码**：
```java
char[] arr = str.toCharArray();
Arrays.sort(arr);
String key = new String(arr);
map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);
```

### 2. 字符计数作为key（优化）

**相关题目**：同上49题的优化解法

**核心思路**：
- 统计每个字符的出现次数作为key
- 避免排序，时间复杂度：O(nk)
- 用数组记录频率，转为字符串作为key

**优势**：比排序法更快，适合性能要求高的场景

### 3. 元素本身作为key

**典型应用**：128.最长连续序列（计划完成）

**核心思路**：
- 将所有元素存入HashSet
- 利用 `set.contains()` O(1)查找
- 只从序列起点开始查找：判断 `num-1` 是否存在

## 设计key的原则

1. **唯一性**：相同特征必须映射到相同key
2. **可计算性**：key生成要高效
3. **稳定性**：相同输入必须产生相同key
4. **避免冲突**：不要用ASCII码之和等易冲突的方法

## 常见陷阱

❌ **key冲突**：使用字符ASCII码之和
- "ab" → 97+98=195
- "ba" → 98+97=195（冲突！）

✅ **正确做法**：使用排序或字符计数

❌ **浮点数作为key**：精度问题（0.1 + 0.2 != 0.3）

✅ **正确做法**：转为字符串或使用Decimal

## 代码简化技巧

```java
// 传统写法
if (!map.containsKey(key)) {
    map.put(key, new ArrayList<>());
}
map.get(key).add(value);

// 简化写法
map.computeIfAbsent(key, k -> new ArrayList<>()).add(value);
```

## 方法对比（49题实测）

| 方法 | 时间复杂度 | 优点 | 缺点 |
|------|-----------|------|------|
| 排序作为key | O(nk log k) | 思路清晰，易实现 | 排序开销大 |
| 字符计数 | O(nk) | 避免排序，更快 | 代码稍复杂 |
| 质数映射 | O(nk) | 数学方法巧妙 | ❌ 有溢出风险 |

**推荐**：面试用方法一，性能要求高用方法二

## 总结

1. **何时使用**：需要快速查找、分组、判断存在性
2. **选择结构**：HashMap（需要value）/ HashSet（只判断存在）
3. **性能优化**：预估大小避免扩容，如 `new HashMap<>(strs.length)`


# 动态规划核心模板 🧠

---

## 🎯 DP 五步法
1. 问题是否具有最优子结构？（子问题的最优组合构成全局最优）
2. 定义状态：dp[i] 表示什么？是否需要二维/滚动？
3. 状态转移：dp[i] 由哪些状态转移而来？（写出方程）
4. 初始条件：dp 的起点是什么？边界如何处理？
5. 结果：答案在 dp 的哪个位置？如何取？

---

## 🔧 常见模型与模板

### 1) 一维线性 DP（爬楼梯）
- 场景：每一步只依赖前面 k 步（常见 k=1/2）
- 定义：dp[i] = 到达第 i 阶的方法数
- 转移：dp[i] = dp[i-1] + dp[i-2]
- 初始：dp[0]=1, dp[1]=1
- 结果：dp[n]

代码（滚动变量）：
```java
public int climbStairs(int n) {
    if (n <= 1) return 1;
    int a = 1, b = 1; // dp[0], dp[1]
    for (int i = 2; i <= n; i++) {
        int c = a + b; // dp[i] = dp[i-1] + dp[i-2]
        a = b;
        b = c;
    }
    return b; // dp[n]
}
```

### 2) 序列最优值（最大子数组和, Kadane）
- 场景：连续子数组/子串最优值
- 定义：curr 表示“以 i 结尾”的最大和；ans 维护全局最大
- 转移：curr = max(nums[i], curr + nums[i])
- 初始：curr=ans=nums[0]
- 结果：ans

代码（Kadane）：
```java
public int maxSubArray(int[] nums) {
    int curr = nums[0], ans = nums[0];
    for (int i = 1; i < nums.length; i++) {
        curr = Math.max(nums[i], curr + nums[i]);
        ans = Math.max(ans, curr);
    }
    return ans;
}
```

等价 DP 数组写法：
```java
// dp[i] = 以 i 结尾的最大子数组和
int[] dp = new int[nums.length];
dp[0] = nums[0];
int ans = dp[0];
for (int i = 1; i < nums.length; i++) {
    dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);
    ans = Math.max(ans, dp[i]);
}
```

### 3) 前缀和辅助（最大子数组和的前缀解法）
- 思路：ans = max(prefix[i] - minPrefix[i-1])
- 在线维护：`curPrefix += x; ans = max(ans, curPrefix - minPrefix); minPrefix = min(minPrefix, curPrefix)`
- 适用于“连续区间和最优”的一类问题

---

## 🧩 分治/线段树（最大子数组和进阶）

- 分治：区间最大 = max(左最大, 右最大, 跨中点最大)，跨中点最大 = 左后缀最大 + 右前缀最大
- 线段树：维护 `sum/prefixMax/suffixMax/best` 四元组，按规则合并

使用场景：需要频繁查询/更新区间最优时（如在线处理）。

---

## ⚠️ 易错点清单
- 初始条件不要错（如爬楼梯 dp[0]=1, dp[1]=1）
- 边界下标：循环从哪里开始，答案在哪个位置
- 全负数组：Kadane/前缀和初始化要能处理负数
- 记忆化递归：记得缓存与边界返回
- 空间优化：只在当前状态仅依赖少量前态时使用

---

## ✅ 本仓库已完成的 DP 题
- 70. 爬楼梯：DP数组 / 滚动变量 / 记忆化
- 53. 最大子数组和：Kadane / DP数组 / 前缀和 / 分治 / 线段树

> 建议顺序：线性 DP 入门（爬楼梯）→ Kadane（子数组最优）→ 背包/打家劫舍/股票（后续专题）

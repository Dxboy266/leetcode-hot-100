# 动态规划核心模板 🧠

---

## 🎯 DP 五步法
1. 问题是否具有最优子结构？（子问题的最优组合构成全局最优）
2. 定义状态：dp[i] 表示什么？是否需要二维/滚动？
3. 状态转移：dp[i] 由哪些状态转移而来？（写出方程）
4. 初始条件：dp 的起点是什么？边界如何处理？
5. 结果：答案在 dp 的哪个位置？如何取？

---

## 🔧 常见模型与模板

### 1) 一维线性 DP（爬楼梯）
- 场景：每一步只依赖前面 k 步（常见 k=1/2）
- 定义：dp[i] = 到达第 i 阶的方法数
- 转移：dp[i] = dp[i-1] + dp[i-2]
- 初始：dp[0]=1, dp[1]=1
- 结果：dp[n]

代码（滚动变量）：
```java
public int climbStairs(int n) {
    if (n <= 1) return 1;
    int a = 1, b = 1; // dp[0], dp[1]
    for (int i = 2; i <= n; i++) {
        int c = a + b; // dp[i] = dp[i-1] + dp[i-2]
        a = b;
        b = c;
    }
    return b; // dp[n]
}
```

### 2) 序列最优值（最大子数组和, Kadane）
- 场景：连续子数组/子串最优值
- 定义：curr 表示"以 i 结尾"的最大和；ans 维护全局最大
- 转移：curr = max(nums[i], curr + nums[i])
- 初始：curr=ans=nums[0]
- 结果：ans

代码（Kadane）：
```java
public int maxSubArray(int[] nums) {
    int curr = nums[0], ans = nums[0];
    for (int i = 1; i < nums.length; i++) {
        curr = Math.max(nums[i], curr + nums[i]);
        ans = Math.max(ans, curr);
    }
    return ans;
}
```

等价 DP 数组写法：
```java
// dp[i] = 以 i 结尾的最大子数组和
int[] dp = new int[nums.length];
dp[0] = nums[0];
int ans = dp[0];
for (int i = 1; i < nums.length; i++) {
    dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);
    ans = Math.max(ans, dp[i]);
}
```

### 3) 选择型DP（打家劫舍）
- 场景：对于每个元素，有选择或不选择两种决策，且决策之间有约束
- 定义：dp[i] = 考虑前 i+1 个元素能获得的最大收益
- 转移：dp[i] = max(dp[i-1], dp[i-2] + nums[i])
  - dp[i-1] 表示不选择第 i 个元素
  - dp[i-2] + nums[i] 表示选择第 i 个元素（不能选择 i-1）
- 初始：dp[0]=nums[0], dp[1]=max(nums[0], nums[1])
- 结果：dp[n-1]

代码（滚动变量）：
```java
public int rob(int[] nums) {
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    int dpI2 = nums[0], dpI1 = Math.max(nums[0], nums[1]);
    int max = dpI1;
    for (int i = 2; i < nums.length; i++) {
        max = Math.max(dpI1, dpI2 + nums[i]);
        dpI2 = dpI1;
        dpI1 = max;
    }
    return max;
}
```

### 4) 前缀和辅助（最大子数组和的前缀解法）
- 思路：ans = max(prefix[i] - minPrefix[i-1])
- 在线维护：`curPrefix += x; ans = max(ans, curPrefix - minPrefix); minPrefix = min(minPrefix, curPrefix)`
- 适用于"连续区间和最优"的一类问题

---

## 🧩 分治/线段树（最大子数组和进阶）

- 分治：区间最大 = max(左最大, 右最大, 跨中点最大)，跨中点最大 = 左后缀最大 + 右前缀最大
- 线段树：维护 `sum/prefixMax/suffixMax/best` 四元组，按规则合并

使用场景：需要频繁查询/更新区间最优时（如在线处理）。

---

## ⚠️ 易错点清单
- 初始条件不要错（如爬楼梯 dp[0]=1, dp[1]=1）
- 边界下标：循环从哪里开始，答案在哪个位置
- 全负数组：Kadane/前缀和初始化要能处理负数
- 记忆化递归：记得缓存与边界返回
- 空间优化：只在当前状态仅依赖少量前态时使用

---

## ✅ 本仓库已完成的 DP 题
- 70. 爬楼梯：DP数组 / 滚动变量 / 记忆化
- 53. 最大子数组和：Kadane / DP数组 / 前缀和 / 分治 / 线段树
- 198. 打家劫舍：DP数组 / 滚动变量 / 记忆化搜索

> 建议顺序：线性 DP 入门（爬楼梯）→ Kadane（子数组最优）→ 选择型DP（打家劫舍）→ 背包/股票（后续专题）
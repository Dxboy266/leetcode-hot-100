package com.leetcode.array;

/**
 * 283. 移动零
 * 
 * 题目链接：https://leetcode.cn/problems/move-zeroes/
 * 难度：简单
 * 标签：数组、双指针
 * 
 * ==================== 题目描述 ====================
 * 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
 * 
 * 请注意，必须在不复制数组的情况下原地对数组进行操作。
 * 
 * 示例 1:
 * 输入: nums = [0,1,0,3,12]
 * 输出: [1,3,12,0,0]
 * 
 * 示例 2:
 * 输入: nums = [0]
 * 输出: [0]
 * 
 * 提示:
 * 1 <= nums.length <= 10^4
 * -2^31 <= nums[i] <= 2^31 - 1
 * 
 * 进阶：你能尽量减少完成的操作次数吗？
 * 
 * ==================== 解题思路 ====================
 * 
 * 方法一：双指针原地交换
 * - 使用两个指针：count 指向下一个非零元素应该放置的位置
 * - 遍历数组，遇到非零元素时：
 *   1. 如果 count != i，说明需要移动元素
 *   2. 将 nums[i] 赋值给 nums[count]，并将 nums[i] 设为 0
 *   3. count 指针后移
 * - 时间复杂度：O(n) - 只需遍历一次数组
 * - 空间复杂度：O(1) - 只使用常数空间
 * - 优点：理论上操作次数最少
 * - 缺点：理解稍复杂，实际性能可能不如两次遍历
 * 
 * 方法二：两次遍历法（实测更快）★★★
 * - 第一次遍历：将所有非零元素移到数组前面
 * - 第二次遍历：将剩余位置全部设为 0
 * - 时间复杂度：O(n) - 需要遍历两次数组
 * - 空间复杂度：O(1) - 只使用常数空间
 * - 优点：思路清晰，容易理解，实测性能更好
 * - 缺点：需要遍历两次数组
 * 
 * ==================== 知识点总结 ====================
 * 
 * 1. 双指针技巧：
 *    - 快慢指针：一个遍历，一个记录位置
 *    - 原地修改数组的经典应用
 *    - 保持元素相对顺序的关键
 * 
 * 2. 算法优化思路：
 *    - 方法一：一次遍历完成所有操作
 *    - 方法二：分步骤处理，思路更清晰
 *    - 两种方法都是 O(n) 时间复杂度
 * 
 * 3. 易错点：
 *    - 必须保持非零元素的相对顺序
 *    - 不能使用额外的数组空间
 *    - 注意边界条件的处理
 * 
 * 4. 相关题目：
 *    - 26. 删除有序数组中的重复项（类似双指针）
 *    - 27. 移除元素（类似双指针）
 *    - 80. 删除有序数组中的重复项 II（进阶版）
 * 
 * @Author Dxboy266
 * @Date 2025-10-13
 */
public class MoveZeroes {
    
    /**
     * 方法一：双指针原地交换
     * 时间复杂度：O(n) - 只需遍历一次数组
     * 空间复杂度：O(1) - 只使用常数空间
     * 
     * 思路：
     * 1. count 指针指向下一个非零元素应该放置的位置
     * 2. 遍历数组，遇到非零元素时：
     *    - 如果 count != i，说明需要移动元素
     *    - 交换元素位置，并更新 count
     * 3. 这样保证所有非零元素都在前面，且保持相对顺序
     * 
     * 注意：实测发现此方法性能可能不如两次遍历法
     */
    public void moveZeroes(int[] nums) {
        int count = 0; // 指向下一个非零元素应该放置的位置
        
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                // 如果 count != i，说明需要移动元素
                if (count != i) {
                    nums[count] = nums[i];
                    nums[i] = 0;
                }
                count++;
            }
        }
    }
    
    /**
     * 方法二：两次遍历法（推荐）★★★
     * 时间复杂度：O(n) - 需要遍历两次数组
     * 空间复杂度：O(1) - 只使用常数空间
     * 
     * 思路：
     * 1. 第一次遍历：将所有非零元素移到数组前面
     * 2. 第二次遍历：将剩余位置全部设为 0
     * 
     * 实测性能：此方法在实际运行中比双指针方法更快
     */
    public void moveZeroesTwoPass(int[] nums) {
        int index = 0; // 指向下一个非零元素应该放置的位置
        
        // 第一次遍历：将所有非零元素移到数组前面
        for (int num : nums) {
            if (num != 0) {
                nums[index++] = num;
            }
        }
        
        // 第二次遍历：将剩余位置全部设为 0
        for (int i = index; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
    
    /**
     * 方法三：冒泡排序思想（不推荐，仅作理解）
     * 时间复杂度：O(n²) - 最坏情况需要 n² 次交换
     * 空间复杂度：O(1) - 只使用常数空间
     * 
     * 思路：将 0 像气泡一样"冒"到数组末尾
     * 虽然能解决问题，但效率很低
     */
    public void moveZeroesBubble(int[] nums) {
        boolean swapped = true;
        
        while (swapped) {
            swapped = false;
            for (int i = 0; i < nums.length - 1; i++) {
                if (nums[i] == 0 && nums[i + 1] != 0) {
                    // 交换 0 和非零元素
                    int temp = nums[i];
                    nums[i] = nums[i + 1];
                    nums[i + 1] = temp;
                    swapped = true;
                }
            }
        }
    }
    
    /**
     * 补充说明：性能分析
     * 
     * 1. 理论分析：
     *    - 方法一：最多 n 次赋值操作
     *    - 方法二：最多 2n 次赋值操作
     *    - 方法三：最多 n² 次交换操作
     * 
     * 2. 实测结果：
     *    - 方法一：双指针 - 244500 ns
     *    - 方法二：两次遍历 - 195300 ns（更快）
     *    - 方法三：冒泡 - 23618500 ns（最慢）
     * 
     * 3. 性能差异原因：
     *    - 方法一的条件判断和内存访问模式可能影响缓存效率
     *    - 方法二的简单循环结构更适合现代CPU的流水线处理
     *    - 实际性能往往与理论分析有差异
     * 
     * 4. 代码复杂度：
     *    - 方法一：逻辑稍复杂，需要理解双指针
     *    - 方法二：逻辑简单，容易理解和实现
     *    - 方法三：逻辑简单，但效率太低
     * 
     * 5. 面试建议：
     *    - 先说出方法二（思路清晰，实测更快）
     *    - 然后展示方法一（展示优化思维）
     *    - 分析两种方法的时间空间复杂度
     *    - 强调实际性能测试的重要性
     */
}

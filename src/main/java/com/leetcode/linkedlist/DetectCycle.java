package com.leetcode.linkedlist;

import com.leetcode.utils.ListNode;

/**
 * 142. 环形链表 II
 * 
 * 题目链接：https://leetcode.cn/problems/linked-list-cycle-ii/
 * 难度：中等
 * 标签：链表、双指针、哈希表
 * 
 * ==================== 题目描述 ====================
 * 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。
 * 如果链表无环，则返回 null。
 * 
 * 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。
 * 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置
 * （索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。
 * 
 * 注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
 * 
 * 不允许修改链表。
 * 
 * 示例 1：
 * 输入：head = [3,2,0,-4], pos = 1
 * 输出：返回索引为 1 的链表节点
 * 解释：链表中有一个环，其尾部连接到第二个节点（值为 2）
 * 
 *     3 → 2 → 0 → -4
 *         ↑__________↓
 * 
 * 示例 2：
 * 输入：head = [1,2], pos = 0
 * 输出：返回索引为 0 的链表节点
 * 解释：链表中有一个环，其尾部连接到第一个节点（值为 1）
 * 
 *     1 → 2
 *     ↑___↓
 * 
 * 示例 3：
 * 输入：head = [1], pos = -1
 * 输出：返回 null
 * 解释：链表中没有环
 * 
 * 提示：
 * - 链表中节点的数目范围在范围 [0, 10^4] 内
 * - -10^5 <= Node.val <= 10^5
 * - pos 的值为 -1 或者链表中的一个有效索引
 * 
 * 进阶：你是否可以使用 O(1) 空间解决此题？
 * 
 * ==================== 解题提示 ====================
 * 
 * 【核心知识点】
 * 1. Floyd 判圈算法（龟兔赛跑算法）
 * 2. 数学推导：找到环入口的位置
 * 
 * 【数学原理】
 * 假设：
 * - 链表头到环入口的距离为 a
 * - 环入口到相遇点的距离为 b
 * - 相遇点到环入口的距离为 c（环的剩余部分）
 * - 环的长度为 b + c
 * 
 * 相遇时：
 * - 慢指针走过的距离：a + b
 * - 快指针走过的距离：a + b + n(b + c)，其中 n 为快指针在环内走的圈数
 * - 因为快指针速度是慢指针的 2 倍：2(a + b) = a + b + n(b + c)
 * - 化简得：a = (n-1)(b + c) + c
 * 
 * 结论：
 * 从链表头和相遇点同时出发，每次走一步，再次相遇的地方就是环的入口！
 * 
 * @Author Dxboy266
 * @Date 2025-10-23
 */
public class DetectCycle {
    
    /**
     * 方法：Floyd 判圈算法 + 数学推导
     * 
     * 算法步骤：
     * 1. 使用快慢指针判断是否有环
     * 2. 如果有环，从头节点和相遇点同时出发
     * 3. 两指针再次相遇的地方就是环的入口
     * 
     * 数学证明：
     * 设链表头到环入口的距离为 a
     * 设环入口到相遇点的距离为 b
     * 设相遇点到环入口的距离为 c（环的剩余部分）
     * 
     * 相遇时：
     * - 慢指针走过：a + b
     * - 快指针走过：a + b + n(b + c)，n 为快指针在环内走的圈数
     * - 因为快指针速度是慢指针的 2 倍：
     *   2(a + b) = a + b + n(b + c)
     *   a + b = n(b + c)
     *   a = n(b + c) - b
     *   a = (n-1)(b + c) + c
     * 
     * 结论：
     * 从头节点到环入口的距离 a = 从相遇点走 (n-1) 圈再走 c 的距离
     * 当 n = 1 时，a = c
     * 所以从头节点和相遇点同时出发，每次走一步，会在环入口相遇
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(1)
     * 
     * @param head 链表头节点
     * @return 环的入口节点，如果无环则返回 null
     */
    public ListNode detectCycle(ListNode head) {
        // 1. 使用快慢指针检测环
        ListNode slow = head;
        ListNode fast = head;
        
        // 快指针每次走两步，慢指针每次走一步
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            // 快慢指针相遇，说明有环
            if (slow == fast) {
                // 2. 找到环的入口
                // 让一个指针从头节点开始，一个指针从相遇点开始
                // 两指针每次走一步，再次相遇的地方就是环的入口
                ListNode ptr1 = head;
                ListNode ptr2 = slow;  // 相遇点
                
                while (ptr1 != ptr2) {
                    ptr1 = ptr1.next;
                    ptr2 = ptr2.next;
                }
                
                // 返回环的入口节点
                return ptr1;
            }
        }
        
        // 3. 快指针到达末尾，说明无环
        return null;
    }
}


package com.leetcode.linkedlist;

import com.leetcode.utils.ListNode;

/**
 * 2. 两数相加
 * 
 * 题目链接：https://leetcode.cn/problems/add-two-numbers/
 * 难度：中等
 * 标签：链表、递归、数学
 * 
 * ==================== 题目描述 ====================
 * 给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，
 * 并且每个节点只能存储一位数字。
 * 
 * 请你将两个数相加，并以相同形式返回一个表示和的链表。
 * 
 * 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
 * 
 * 示例 1：
 * 输入：l1 = [2,4,3], l2 = [5,6,4]
 * 输出：[7,0,8]
 * 解释：342 + 465 = 807
 * 
 * 示例 2：
 * 输入：l1 = [0], l2 = [0]
 * 输出：[0]
 * 
 * 示例 3：
 * 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
 * 输出：[8,9,9,9,0,0,0,1]
 * 解释：9999999 + 9999 = 10009998
 * 
 * 提示：
 * - 每个链表中的节点数在范围 [1, 100] 内
 * - 0 <= Node.val <= 9
 * - 题目数据保证列表表示的数字不含前导零
 * 
 * ==================== 解题思路 ====================
 * 
 * 【核心思路：模拟竖式加法】
 * 
 * 这道题就像我们在小学学的竖式加法：
 * 1. 从个位（链表头）开始逐位相加
 * 2. 每次相加都要考虑来自上一位的进位
 * 3. 如果当前位和 ≥ 10，需要向下一位进位
 * 
 * 例如：342 + 465 = 807
 * 
 *     链表：2 → 4 → 3  (表示 342)
 *          5 → 6 → 4  (表示 465)
 *          -----------
 *     结果：7 → 0 → 8  (表示 807)
 * 
 * 第1步：2 + 5 = 7，无进位
 * 第2步：4 + 6 = 10，进位 1，当前位 0
 * 第3步：3 + 4 + 1(进位) = 8，无进位
 * 
 * 【关键技巧】
 * 1. 虚拟头节点 (Dummy Head)：
 *    - 创建一个哑节点作为结果链表的头，简化边界处理
 *    - 最后返回 dummyHead.next
 * 
 * 2. 进位变量 (Carry)：
 *    - 用一个整数变量 carry 存储进位（0 或 1）
 *    - carry = sum / 10（整除得进位）
 *    - 当前位 = sum % 10（取余得当前位）
 * 
 * 3. 循环条件：
 *    - while (l1 != null || l2 != null || carry != 0)
 *    - 只要三者有一个不为空/0，就继续循环
 *    - 这样可以处理：
 *      ① 两个链表长度不同
 *      ② 最后一位有进位（如 99 + 1 = 100）
 * 
 * 4. 链表长度不同的处理：
 *    - 当某个链表遍历完后，将其值视为 0
 *    - if (l1 != null) sum += l1.val
 * 
 * 【算法步骤】
 * 1. 创建虚拟头节点 dummyHead 和当前节点指针 current
 * 2. 初始化进位 carry = 0
 * 3. 同时遍历两个链表：
 *    a. 计算当前位的和：sum = l1.val + l2.val + carry
 *    b. 更新进位：carry = sum / 10
 *    c. 创建新节点：current.next = new ListNode(sum % 10)
 *    d. 移动指针
 * 4. 返回 dummyHead.next
 * 
 * 时间复杂度：O(max(m, n))，m 和 n 分别是两个链表的长度
 * 空间复杂度：O(max(m, n))，结果链表的长度
 * 
 * @Author Dxboy266
 * @Date 2025-10-21
 */
public class AddTwoNumbers {
    
    /**
     * 模拟竖式加法
     * 
     * 核心思路：
     * 1. 使用虚拟头节点简化链表操作
     * 2. 同时遍历两个链表，逐位相加
     * 3. 用 carry 变量记录进位
     * 4. 循环条件包含 carry，处理最后的进位
     * 
     * 时间复杂度：O(max(m, n))
     * 空间复杂度：O(max(m, n))
     * 
     * @param l1 第一个链表（逆序存储的数字）
     * @param l2 第二个链表（逆序存储的数字）
     * @return 和的链表（逆序存储）
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 1. 创建虚拟头节点，简化链表操作
        ListNode dummyHead = new ListNode(-1);
        ListNode current = dummyHead; // 当前节点指针
        int carry = 0; // 进位，初始为 0

        // 2. 同时遍历两个链表，直到两个链表都遍历完且无进位
        // 关键：循环条件包含 carry，确保处理最后的进位
        while (l1 != null || l2 != null || carry != 0) {
            // 3. 计算当前位的和
            int sum = carry; // 先加上进位
            
            // 如果 l1 还有节点，加上 l1 的值
            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next; // 移动到下一个节点
            }
            
            // 如果 l2 还有节点，加上 l2 的值
            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next; // 移动到下一个节点
            }
            
            // 4. 计算新的进位和当前位的值
            carry = sum / 10;      // 进位：sum >= 10 时为 1，否则为 0
            int digit = sum % 10;  // 当前位：sum 的个位数
            
            // 5. 创建新节点并连接到结果链表
            current.next = new ListNode(digit);
            current = current.next; // 移动当前指针
        }
        
        // 6. 返回结果链表（跳过虚拟头节点）
        return dummyHead.next;
    }
}

package com.leetcode.stack;

import java.util.Stack;

/**
 * 739. 每日温度
 * 
 * 题目链接：https://leetcode.cn/problems/daily-temperatures/
 * 难度：中等
 * 标签：栈、数组、单调栈
 * 
 * ==================== 题目描述 ====================
 * 给定一个整数数组 temperatures，表示每天的温度，返回一个数组 answer，
 * 其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。
 * 如果气温在这之后都不会升高，请在该位置用 0 来代替。
 * 
 * 示例 1：
 * 输入：temperatures = [73,74,75,71,69,72,76,73]
 * 输出：[1,1,4,2,1,1,0,0]
 * 解释：
 *   - 第 0 天 (73°)：第 1 天 (74°) 更高，等待 1 天
 *   - 第 1 天 (74°)：第 2 天 (75°) 更高，等待 1 天
 *   - 第 2 天 (75°)：第 6 天 (76°) 更高，等待 4 天
 *   - 第 3 天 (71°)：第 5 天 (72°) 更高，等待 2 天
 *   - 第 4 天 (69°)：第 5 天 (72°) 更高，等待 1 天
 *   - 第 5 天 (72°)：第 6 天 (76°) 更高，等待 1 天
 *   - 第 6 天 (76°)：之后没有更高温度，输出 0
 *   - 第 7 天 (73°)：之后没有更高温度，输出 0
 * 
 * 示例 2：
 * 输入：temperatures = [30,40,50,60]
 * 输出：[1,1,1,0]
 * 
 * 示例 3：
 * 输入：temperatures = [30,60,90]
 * 输出：[1,1,0]
 * 
 * 提示：
 * - 1 <= temperatures.length <= 10^5
 * - 30 <= temperatures[i] <= 100
 * 
 * ==================== 解题思路 ====================
 * 
 * 【方法一：暴力解法】
 * 思路：对于每一天，向后遍历找到第一个更高的温度
 * 时间复杂度：O(n²) - 双层循环
 * 空间复杂度：O(1) - 只使用结果数组
 * 缺点：数据量大时会超时（如 n = 10^5）
 * 
 * 【方法二：单调栈（推荐）】
 * 核心思想：
 * 1. 维护一个单调递减栈，存储待查找"下一个更高温度"的日期索引
 * 2. 从左到右遍历，当遇到更高温度时，栈中所有温度比它低的日期都找到了答案
 * 3. 关键点：
 *    - 栈中存储的是索引（而非温度值），方便计算天数差
 *    - 栈从底到顶，对应的温度值单调递减（大 → 小）
 *    - 使用 while 循环弹出，因为当前温度可能是多个栈内元素的答案
 * 
 * 时间复杂度：O(n) - 每个元素最多入栈、出栈各一次
 * 空间复杂度：O(n) - 栈的最大空间
 * 
 * 单调栈适用场景：
 * - 寻找"下一个更大/更小元素"问题
 * - 寻找"上一个更大/更小元素"问题
 * - 柱状图面积、接雨水等问题
 * 
 * ==================== 执行过程示例 ====================
 * temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
 * 
 * i=0, temp=73: stack=[0]
 * i=1, temp=74: 74>73 → pop 0, res[0]=1-0=1, stack=[1]
 * i=2, temp=75: 75>74 → pop 1, res[1]=2-1=1, stack=[2]
 * i=3, temp=71: 71<75, stack=[2,3]
 * i=4, temp=69: 69<71, stack=[2,3,4]
 * i=5, temp=72: 72>69 → pop 4, res[4]=5-4=1
 *               72>71 → pop 3, res[3]=5-3=2
 *               72<75, stack=[2,5]
 * i=6, temp=76: 76>72 → pop 5, res[5]=6-5=1
 *               76>75 → pop 2, res[2]=6-2=4
 *               stack=[6]
 * i=7, temp=73: 73<76, stack=[6,7]
 * 
 * 最终结果：res = [1, 1, 4, 2, 1, 1, 0, 0]
 * 
 * @Author Dxboy266
 * @Date 2025-10-20
 */
public class DailyTemperatures {
    
    /**
     * 方法一：暴力解法
     * 
     * 思路：对于每一天，向后遍历数组找到第一个比当前温度高的日期
     * 
     * 时间复杂度：O(n²)
     * - 外层循环 n 次，内层最坏情况循环 n 次
     * - 对于大数据量（如 n = 10^5），会导致超时
     * 
     * 空间复杂度：O(1)
     * - 只使用了结果数组，不算额外空间
     * 
     * @param temperatures 每天的温度数组
     * @return 等待天数数组
     */
    public int[] dailyTemperaturesBruteForce(int[] temperatures) {
        int n = temperatures.length;
        int[] res = new int[n]; // 默认值为 0，表示之后没有更高温度
        
        // 外层循环：遍历每一天
        for (int i = 0; i < n; i++) {
            // 内层循环：向后查找第一个更高的温度
            for (int j = i + 1; j < n; j++) {
                if (temperatures[j] > temperatures[i]) {
                    res[i] = j - i; // 记录等待天数
                    break; // 找到后立即退出内层循环
                }
            }
            // 如果没找到，res[i] 保持默认值 0
        }
        
        return res;
    }

    /**
     * 方法二：单调栈（推荐）
     * 
     * 核心思想：
     * 维护一个单调递减栈，栈中存储"尚未找到下一个更高温度"的日期索引。
     * 当遇到更高温度时，栈中所有比它低的温度都找到了答案。
     * 
     * 算法步骤：
     * 1. 遍历温度数组，对于每个温度：
     * 2. 如果当前温度 > 栈顶索引对应的温度，说明找到了栈顶日期的答案
     *    - 弹出栈顶索引，计算天数差（当前索引 - 栈顶索引）
     *    - 重复步骤 2，直到栈为空或当前温度 <= 栈顶温度
     * 3. 将当前索引入栈，等待后续找到更高温度
     * 4. 遍历结束后，栈中剩余的索引表示之后没有更高温度，结果保持默认值 0
     * 
     * 关键点：
     * - 栈中存储索引而非温度值，方便计算天数差
     * - 栈从底到顶，对应的温度值单调递减（形成"单调递减栈"）
     * - 使用 while 循环弹出，因为当前温度可能是多个栈内元素的答案
     * 
     * 时间复杂度：O(n)
     * - 每个元素最多入栈一次、出栈一次，总操作次数 = 2n
     * - 虽然有嵌套循环，但均摊时间复杂度为 O(n)
     * 
     * 空间复杂度：O(n)
     * - 栈的最大空间：最坏情况（递减序列）所有元素都在栈中
     * 
     * 单调栈模板总结：
     * ┌─────────────────────────────────────────────────┐
     * │ Stack<Integer> stack = new Stack<>();          │
     * │ for (int i = 0; i < n; i++) {                  │
     * │     while (!stack.isEmpty() &&                 │
     * │            condition(i, stack.peek())) {       │
     * │         int index = stack.pop();               │
     * │         // 处理 index 的答案                     │
     * │     }                                          │
     * │     stack.push(i);                             │
     * │ }                                              │
     * └─────────────────────────────────────────────────┘
     * 
     * @param temperatures 每天的温度数组
     * @return 等待天数数组
     */
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] res = new int[n]; // 默认值为 0
        Stack<Integer> stack = new Stack<>(); // 单调递减栈，存储索引
        
        // 遍历每一天的温度
        for (int i = 0; i < n; i++) {
            // 【关键】当前温度大于栈顶索引对应的温度时
            // 说明找到了栈顶日期的"下一个更高温度"
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int prevIndex = stack.pop(); // 弹出找到答案的日期索引
                res[prevIndex] = i - prevIndex; // 计算等待天数
            }
            
            // 将当前索引入栈，等待找到它的"下一个更高温度"
            stack.push(i);
        }
        
        // 栈中剩余的索引表示之后没有更高温度，res 默认值已经是 0
        return res;
    }
}


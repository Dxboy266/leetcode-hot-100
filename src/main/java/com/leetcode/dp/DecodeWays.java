package com.leetcode.dp;

/**
 * 91. 解码方法 (Decode Ways)
 *
 * 题目链接：https://leetcode.cn/problems/decode-ways/
 * 难度：中等
 * 标签：动态规划、字符串
 *
 * ==================== 题目描述 ====================
 * 一条包含字母 A-Z 的消息通过以下映射进行了编码：
 *
 * 'A' -> 1
 * 'B' -> 2
 * ...
 * 'Z' -> 26
 *
 * 现在，给定一个只包含数字的非空字符串，计算共有多少种不同的解码方式。
 * 题目数据保证答案肯定是一个 32 位的整数。
 *
 * 示例 1：
 * 输入："11"
 * 输出：2
 * 解释：它可以解码为 "AA" (1, 1) 或 "K" (11)。
 *
 * 示例 2：
 * 输入："10"
 * 输出：1
 * 解释：它只能解码为 "J" (10)。"1" 和 "0" 的组合是无效的，因为 0 不能单独解码。
 *
 * 示例 3：
 * 输入："100"
 * 输出：0
 * 解释：尝试解码：
 *   - 最后一个字符是 '0'，不能单独解码。
 *   - 最后两个字符是 "00"，无效。
 *   - 因此，没有合法的解码方式。
 *
 * 示例 4：
 * 输入："226"
 * 输出：3
 * 解释：它可以解码为：
 *   1. "BBF" (2, 2, 6)
 *   2. "VF" (22, 6)
 *   3. "BZ" (2, 26)
 *
 * 提示：
 * - 1 <= s.length <= 100
 * - s 只包含数字，并且可能包含前导零
 *
 * ==================== 核心规则与约束条件 ====================
 * 1. 单数字解码：数字 1-9 可以单独解码为对应的字母 A-I。
 * 2. 双数字解码：数字 10-26 可以解码为对应的字母 J-Z。
 * 3. 关于 '0' 的限制：
 *    - 数字 0 不能单独解码为任何字母。
 *    - 0 不能作为双数字的开头（例如 "01"、"02" 等都是无效的）。
 * 4. 整体有效性：如果整个数字串包含无法解码的部分（例如 "100" 中的 "00"），则整个串的解码方式数为 0。
 *
 * ==================== 解题提示 ====================
 * 定义状态：dp[i] 表示字符串前 i 个字符的解码方法数
 * 转移方程：
 *   - 如果 s[i-1] 可以单独解码（1-9），dp[i] += dp[i-1]
 *   - 如果 s[i-2:i] 可以作为两位数解码（10-26），dp[i] += dp[i-2]
 * 初始条件：
 *   - dp[0] = 1（空字符串有一种解码方式）
 *   - dp[1] = 1（如果第一个字符不是 '0'）
 * 目标：dp[n]
 *
 * 注意事项：
 * - 需要特别处理 '0' 的情况
 * - 可以使用滚动变量优化空间复杂度到 O(1)
 *
 * @Author Dxboy266
 * @Date 2025-11-07
 */
public class DecodeWays {

    /**
     * 解法一：动态规划（数组）
     * 时间复杂度：O(n)，其中 n 是字符串长度
     * 空间复杂度：O(n)
     *
     * @param s 待解码的数字字符串
     * @return 解码方法数
     */
    public int numDecodings(String s) {
        int[] dp = new int[s.length() + 1];
        dp[0] = 1;
        for (int i = 1; i <= s.length(); i++) {
            // 如果当前字符不是'0'，可以单独解码
            if (s.charAt(i - 1) != '0') {
                dp[i] += dp[i - 1];
            }
            // 如果前两个字符可以组成有效两位数(10-26)，可以联合解码
            if (i >= 2 && isValidDouble(s.charAt(i - 2), s.charAt(i - 1))) {
                dp[i] += dp[i - 2];
            }
            // 如果当前位置没有解码方法，说明字符串无效
            if (dp[i] == 0) {
                return 0;
            }
        }
        return dp[s.length()];
    }

    /**
     * 解法二：动态规划（空间优化）
     * 时间复杂度：O(n)
     * 空间复杂度：O(1)
     *
     * @param s 待解码的数字字符串
     * @return 解码方法数
     */
    public int numDecodingsOptimized(String s) {
        if (s == null || s.length() == 0) return 0;
        
        // 使用三个变量代替dp数组
        int prev2 = 1;  // dp[i-2]
        int prev1 = s.charAt(0) == '0' ? 0 : 1;  // dp[i-1]
        
        for (int i = 2; i <= s.length(); i++) {
            int current = 0;
            
            // 如果当前字符不是'0'，可以单独解码
            if (s.charAt(i - 1) != '0') {
                current += prev1;
            }
            
            // 如果前两个字符可以组成有效两位数(10-26)，可以联合解码
            if (isValidDouble(s.charAt(i - 2), s.charAt(i - 1))) {
                current += prev2;
            }
            
            // 更新状态
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }

    /**
     * 辅助方法：判断两个字符组成的数字是否可以解码
     * @param c1 第一个字符
     * @param c2 第二个字符
     * @return 是否可以解码
     */
    private boolean isValidDouble(char c1, char c2) {
        // 第一个字符不能是'0'
        if (c1 == '0') return false;
        
        // 组成的数字必须在10-26之间
        int num = (c1 - '0') * 10 + (c2 - '0');
        return num >= 10 && num <= 26;
    }
}
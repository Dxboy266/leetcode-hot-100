package com.leetcode.dp;

import java.util.LinkedList;
import java.util.Queue;

/**
 * 279. 完全平方数
 * 
 * 题目链接：https://leetcode.cn/problems/perfect-squares/
 * 难度：中等
 * 标签：动态规划、数学、广度优先搜索
 * 
 * ==================== 题目描述 ====================
 * 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
 * 
 * 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。
 * 例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
 * 
 * 示例 1：
 * 输入：n = 12
 * 输出：3 
 * 解释：12 = 4 + 4 + 4
 * 
 * 示例 2：
 * 输入：n = 13
 * 输出：2
 * 解释：13 = 4 + 9
 * 
 * 提示：
 * - 1 <= n <= 10^4
 * 
 * ==================== 解题思路 ====================
 * 方法一：动态规划（完全背包）★★★
 * 思路：
 * 1. 这是一个完全背包问题的变形：
 *    - 物品：完全平方数 1, 4, 9, 16, 25, ... (可以无限使用)
 *    - 背包容量：n
 *    - 目标：求最少物品数量
 * 
 * 2. 状态定义：
 *    dp[i] 表示和为 i 的完全平方数的最少数量
 * 
 * 3. 状态转移：
 *    对于每个数 i，遍历所有完全平方数 j*j (j*j <= i)：
 *    dp[i] = min(dp[i], dp[i - j*j] + 1)
 * 
 * 4. 初始化：
 *    - dp[0] = 0（和为0需要0个完全平方数）
 *    - dp[i] = i（最坏情况：i 个 1 相加，即 1+1+...+1）
 * 
 * 5. 返回结果：dp[n]
 * 
 * 时间复杂度：O(n * sqrt(n))
 * 空间复杂度：O(n)
 * 
 * 方法二：BFS（广度优先搜索）
 * 思路：
 * 1. 将问题看作图的最短路径问题：
 *    - 起点：0
 *    - 终点：n
 *    - 每次可以选择加上一个完全平方数，相当于走一步
 * 
 * 2. 使用 BFS 找到从 0 到 n 的最短路径
 * 
 * 时间复杂度：O(n * sqrt(n))
 * 空间复杂度：O(n)
 * 
 * 方法三：数学定理（四平方和定理）
 * 思路：
 * 1. 拉格朗日四平方和定理：任何正整数都可以表示为至多 4 个完全平方数的和
 * 2. 进一步优化：
 *    - 如果 n 本身是完全平方数，返回 1
 *    - 如果 n 可以表示为 2 个完全平方数的和，返回 2
 *    - 如果 n 满足 4^k * (8m + 7) 的形式，返回 4
 *    - 否则返回 3
 * 
 * 时间复杂度：O(sqrt(n))
 * 空间复杂度：O(1)
 * 
 * ==================== 知识点总结 ====================
 * 1. 完全背包问题：
 *    - 每个物品可以无限次使用
 *    - 求最少数量：初始化为最大值，取 min
 *    - 求最多数量：初始化为最小值，取 max
 * 
 * 2. 与零钱兑换的对比：
 *    - 零钱兑换：硬币面额固定，给定 coins 数组
 *    - 完全平方数：物品是 1, 4, 9, 16, ..., 需要自己生成
 * 
 * 3. 数学优化：
 *    - 四平方和定理：答案只可能是 1, 2, 3, 4
 *    - 可以先判断特殊情况，再用 DP
 * 
 * 4. 相关题目：
 *    - 322. 零钱兑换（完全背包求最少数量）
 *    - 518. 零钱兑换 II（完全背包求组合数）
 *    - 377. 组合总和 Ⅳ（完全背包求排列数）
 * 
 * 5. 易错点：
 *    - 初始化：dp[0] = 0，其他可以初始化为 i（最坏情况）
 *    - 循环范围：j*j <= i，注意不要越界
 *    - 完全平方数的生成：从 1 开始，j*j <= n
 * 
 * @Author Dxboy266
 * @Date 2025-11-19
 */
public class NumSquares {
    
    /**
     * 方法一：动态规划（完全背包）★★★
     * 时间复杂度：O(n * sqrt(n))
     * 空间复杂度：O(n)
     *
     * 为什么这么写？
     * 1. 这是一个完全背包问题：
     *    - 物品：完全平方数 1, 4, 9, 16, ...（可以无限使用）
     *    - 背包容量：n
     *    - 目标：求最少物品数量
     *
     * 2. 状态转移方程的推导：
     *    - 要凑成数字 i，可以选择任意一个完全平方数 j*j（j*j <= i）
     *    - 选择 j*j 后，还需要凑成 i - j*j
     *    - 所以：dp[i] = min(dp[i - j*j] + 1)，对所有可能的 j
     *
     * 3. 为什么初始化 dp[i] = i？
     *    - 最坏情况：用 i 个 1 相加，即 1+1+...+1 = i
     *    - 这保证了 dp[i] 有一个合法的初始值
     *
     * 4. 为什么是完全背包而不是 0-1 背包？
     *    - 每个完全平方数可以使用多次（例如 12 = 4 + 4 + 4）
     *    - 完全背包：正序遍历，允许重复使用
     *    - 0-1 背包：倒序遍历，每个物品只能用一次
     *
     * @param n 目标数字
     * @return 和为 n 的完全平方数的最少数量
     */
    public int numSquares(int n) {
        // 1. 创建 dp 数组，dp[i] 表示和为 i 的完全平方数的最少数量
        int[] dp = new int[n + 1];

        // 2. 初始化：dp[0] = 0（凑成 0 需要 0 个完全平方数）
        dp[0] = 0;

        // 3. 状态转移：从 1 到 n 逐个计算
        for (int i = 1; i <= n; i++) {
            // 初始化为最坏情况：i 个 1 相加
            dp[i] = i;

            // 尝试所有可能的完全平方数 j*j
            for (int j = 1; j * j <= i; j++) {
                // 状态转移方程：dp[i] = min(dp[i], dp[i - j*j] + 1)
                // 含义：选择完全平方数 j*j，还需要 dp[i - j*j] 个完全平方数
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }

        // 4. 返回 dp[n]
        return dp[n];
    }
    
    /**
     * 方法二：BFS（广度优先搜索）
     * 时间复杂度：O(n * sqrt(n))
     * 空间复杂度：O(n)
     *
     * 为什么这么写？
     * 1. 将问题转化为图的最短路径问题：
     *    - 节点：0 到 n 的所有数字
     *    - 边：如果 a + j*j = b（j*j 是完全平方数），则 a 到 b 有一条边
     *    - 目标：找从 0 到 n 的最短路径
     *
     * 2. 为什么用 BFS 而不是 DFS？
     *    - BFS 按层遍历，第一次到达目标就是最短路径
     *    - DFS 需要遍历所有路径才能找到最短的，效率低
     *
     * 3. 为什么需要 visited 数组？
     *    - 避免重复访问同一个数字
     *    - 例如：5 可以从 1+4 或 4+1 到达，只需要访问一次
     *    - 第一次到达某个数字时，一定是最短路径（BFS 的性质）
     *
     * 4. BFS 的层次结构：
     *    - 第 0 层：0
     *    - 第 1 层：0 + 1, 0 + 4, 0 + 9, ... (所有完全平方数)
     *    - 第 2 层：第 1 层的数字 + 完全平方数
     *    - ...
     *    - 第一次到达 n 时，层数就是答案
     *
     * @param n 目标数字
     * @return 和为 n 的完全平方数的最少数量
     */
    public int numSquaresBFS(int n) {
        // 1. 使用队列进行 BFS
        Queue<Integer> queue = new LinkedList<>();

        // 2. 使用 visited 数组标记已访问的数字
        //    visited[i] = true 表示数字 i 已经被访问过
        boolean[] visited = new boolean[n + 1];

        // 3. 从 0 开始，初始化队列和访问标记
        queue.offer(0);
        visited[0] = true;

        // 4. 记录当前层数（即使用的完全平方数的个数）
        int step = 0;

        // 5. BFS 主循环
        while (!queue.isEmpty()) {
            // 当前层的节点数量
            int size = queue.size();
            step++; // 进入下一层

            // 6. 处理当前层的所有节点
            for (int i = 0; i < size; i++) {
                int current = queue.poll();

                // 7. 尝试加上所有可能的完全平方数
                for (int j = 1; j * j <= n; j++) {
                    int next = current + j * j;

                    // 8. 如果到达目标，返回步数
                    if (next == n) {
                        return step;
                    }

                    // 9. 如果 next 超过 n 或已访问过，跳过
                    if (next > n || visited[next]) {
                        continue;
                    }

                    // 10. 标记为已访问，加入队列
                    visited[next] = true;
                    queue.offer(next);
                }
            }
        }

        // 理论上不会到达这里（因为至少可以用 n 个 1 凑成 n）
        return step;
    }
    
    /**
     * 方法三：数学定理（四平方和定理）
     * 时间复杂度：O(sqrt(n))
     * 空间复杂度：O(1)
     *
     * 为什么这么写？
     * 1. 拉格朗日四平方和定理（Lagrange's Four-Square Theorem）：
     *    - 任何正整数都可以表示为至多 4 个完全平方数的和
     *    - 也就是说，答案只可能是 1, 2, 3, 4 中的一个
     *
     * 2. 勒让德三平方和定理（Legendre's Three-Square Theorem）：
     *    - 一个正整数可以表示为 3 个完全平方数的和，当且仅当它不是 4^k * (8m + 7) 的形式
     *    - 换句话说，如果 n = 4^k * (8m + 7)，则答案一定是 4
     *
     * 3. 判断流程（按优先级）：
     *    a) 答案为 1：n 本身是完全平方数
     *       例如：n = 4, 9, 16, 25, ...
     *
     *    b) 答案为 4：n 满足 4^k * (8m + 7) 的形式
     *       例如：n = 7 (4^0 * 7), 15 (4^0 * 15), 28 (4^1 * 7), 63 (4^0 * 63)
     *       为什么？先除以所有的 4，然后判断余数是否为 7 (mod 8)
     *
     *    c) 答案为 2：n 可以表示为 2 个完全平方数的和
     *       例如：n = 2 (1+1), 5 (1+4), 10 (1+9), 13 (4+9)
     *       需要遍历所有可能的 i，判断 n - i*i 是否是完全平方数
     *
     *    d) 答案为 3：其他所有情况
     *       例如：n = 3, 6, 11, 12, ...
     *
     * 4. 为什么这个顺序？
     *    - 先判断 1 和 4：时间复杂度 O(log n) 或 O(1)
     *    - 再判断 2：时间复杂度 O(sqrt(n))
     *    - 最后判断 3：排除法，O(1)
     *
     * @param n 目标数字
     * @return 和为 n 的完全平方数的最少数量
     */
    public int numSquaresMath(int n) {
        // ========== 判断答案是否为 1 ==========
        // 如果 n 本身是完全平方数，返回 1
        if (isPerfectSquare(n)) {
            return 1;
        }

        // ========== 判断答案是否为 4 ==========
        // 根据勒让德三平方和定理：
        // 如果 n = 4^k * (8m + 7)，则答案一定是 4

        // 先除以所有的 4（即 4^k）
        int temp = n;
        while (temp % 4 == 0) {
            temp /= 4;
        }

        // 判断剩余的数是否满足 8m + 7 的形式
        // 即：temp % 8 == 7
        if (temp % 8 == 7) {
            return 4;
        }

        // ========== 判断答案是否为 2 ==========
        // 遍历所有可能的 i，判断 n - i*i 是否是完全平方数
        // 如果是，说明 n = i*i + j*j，答案为 2
        for (int i = 1; i * i <= n; i++) {
            int remain = n - i * i;
            if (isPerfectSquare(remain)) {
                return 2;
            }
        }

        // ========== 答案为 3 ==========
        // 排除法：不是 1, 2, 4，那就是 3
        // 根据四平方和定理，答案一定存在
        return 3;
    }

    /**
     * 辅助方法：判断一个数是否是完全平方数
     *
     * 为什么这么写？
     * 1. 使用 Math.sqrt() 计算平方根
     * 2. 将结果转换为整数（向下取整）
     * 3. 判断 sqrt * sqrt 是否等于 n
     *
     * 注意：
     * - Math.sqrt() 返回 double，可能有精度问题
     * - 但对于 int 范围内的数，这个方法是准确的
     *
     * @param n 待判断的数
     * @return 是否是完全平方数
     */
    private boolean isPerfectSquare(int n) {
        int sqrt = (int) Math.sqrt(n);
        return sqrt * sqrt == n;
    }
}

